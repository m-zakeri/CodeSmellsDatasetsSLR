"Document Title",Authors,"Author Affiliations","Publication Title",Date Added To Xplore,"Publication Year","Volume","Issue","Start Page","End Page","Abstract","ISSN",ISBNs,"DOI",Funding Information,PDF Link,"Author Keywords","IEEE Terms","INSPEC Controlled Terms","INSPEC Non-Controlled Terms","Mesh_Terms",Article Citation Count,Patent Citation Count,"Reference Count","License",Online Date,Issue Date,"Meeting Date","Publisher",Document Identifier
"An Effective Web Service Anti-Pattern Prediction Model Using SMOTE","S. Tummalapalli; L. kumar; L. B. Murthy Neti","BITS Pilani Hyderabad Campus, India; BITS Pilani Hyderabad Campus, India; BITS Pilani Hyderabad Campus, India","2019 IEEE 16th India Council International Conference (INDICON)","12 Mar 2020","2019","","","1","4","An anti-pattern is a common response to a recurring problem that is usually ineffective and risks being highly counterproductive. In this work, we empirically investigate the association between the occurrence of four different types of anti-patterns and source code metrics. SMOTE is being used for data sampling as the dataset considered is imbalanced. Principle component analysis and Rough set analysis are applied for feature extraction and selection. The features selected from this two techniques along with the significant features(SIGF) are considered as input for building the predictive models for the detection of antipatterns. The effectiveness of these techniques are evaluated using Logistic Regression(LOGR), Decision Tree(DT) and Least Square Support Vector Machine(LSSVM) with three different kernels:Linear(LSVVML), Polynomial(LSSVMP) and Radbas(LSSVMR). Experimental results reveal that the model developed using SMOTE is yielding better results when compared to the models developed with the original dataset. Furthermore, we also observe that the predictive model developed using LSSVM with linear and polynomial is more effective than the models developed using other classifier techniques.","2325-9418","978-1-7281-2327-1","10.1109/INDICON47234.2019.9029090","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9029090","Software Engineering;Service oriented architecture;Anti-pattern;Web services;Source code metrics","Measurement;Feature extraction;Predictive models;Web services;Principal component analysis;Object oriented modeling;Data models","decision trees;feature extraction;feature selection;least squares approximations;pattern classification;regression analysis;rough set theory;sampling methods;support vector machines;Web services","LSSVMR;LSSVMP;LSVVML;least square support vector machine;decision tree;logistic regression;feature selection;rough set analysis;Web service anti-pattern prediction model;source code metrics;SMOTE;feature extraction;principle component analysis;data sampling","","","","8","IEEE","12 Mar 2020","","","IEEE","IEEE Conferences"
"Design Smell Detection and Analysis for Open Source Java Software","A. Imran","Computer Science and Engineering, University at Buffalo, Buffalo, New York","2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)","5 Dec 2019","2019","","","644","648","Software design smells have gained significant importance in recent years since those directly lead to the increase of design debts and drastically affect software quality. Although the impact of design smells is manifold, techniques to detect design smells using both rule based and data mining approaches have been explored to a limited extent. This research aims to provide a tool which uses software metrics as a guide to detect smells and also deploys Spectral Clustering to mine the software repositories and group similar smells. The tool has been partially implemented till now and initial experiments on 2,59,509 Lines of Code (LoC) covering 3,306 classes of real life open source Java software show 2,220 occurrences of four types of design smells.","2576-3148","978-1-7281-3094-1","10.1109/ICSME.2019.00104","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8919054","Design Smell Detection, Design Smell Analysis, Software Engineering","Software;Tools;Java;Software metrics;Machine learning;Unsupervised learning;Data mining","data mining;Java;object-oriented programming;pattern clustering;public domain software;software maintenance;software metrics;software quality","data mining approaches;software metrics;software repositories;life open source Java software;design smell detection;software design smells;gained significant importance;design debts;software quality","","1","","31","IEEE","5 Dec 2019","","","IEEE","IEEE Conferences"
"An Empirical Analysis on Web Service Anti-pattern Detection Using a Machine Learning Framework","L. Kumar; A. Sureka","BITS Pilani, Hyderabad, India; Ashoka University, India","2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC)","22 Jun 2018","2018","01","","2","11","Web Services are application components characterised by interoperability, extensibility, distributed application development and service oriented architecture. A complex distributed application can be developed by combing several third-party web-services. Anti-patterns are counter-productive and poor design and practices. Web-services suffer from a multitude of anti-patterns such as God object Web service and Fine grained Web service. Our work is motivated by the need to build techniques for automatically detecting common web-services anti-patterns by static analysis of the source code implementing a web-service. Our approach is based on the premise that summary values of object oriented source code metrics computed at a web-service level can be used as a predictor for anti-patterns. We present an empirical analysis of 4 data sampling techniques to encounter the class imbalance problem, 5 feature ranking techniques to identify the most informative and relevant features and 8 machine learning algorithms for predicting 5 different types of anti-patterns on 226 real-world web-services across several domains. We conclude that it is possible to predict anti-patterns using source code metrics and a machine learning framework. Our analysis reveals that the best performing classification algorithm is Random Forest, best performing data sampling technique is SMOTE and the best performing feature ranking method is OneR.","0730-3157","978-1-5386-2667-2","10.1109/COMPSAC.2018.00010","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377634","Anti Patterns, Empirical Software Engineering, Feature Selection, Imbalanced Learning, Machine Learning, Predictive Modeling, Service Oriented Architecture, Software Analytics, Source Code Analysis, Source Code Metrics, Web Services","Measurement;Web services;Prediction algorithms;Feature extraction;Machine learning;Machine learning algorithms;Tools","learning (artificial intelligence);object-oriented programming;pattern classification;program diagnostics;software metrics;source code (software);Web services","Web service anti-pattern detection;Web Services;distributed application development;service oriented architecture;complex distributed application;third-party web-services;God object Web service;Fine grained Web service;common web-services anti-patterns;object oriented source code metrics;web-service level;real-world web-services;machine learning framework;static analysis;class imbalance problem;feature ranking techniques;classification algorithm;Random Forest","","11","","23","IEEE","22 Jun 2018","","","IEEE","IEEE Conferences"
"Poster: Machine Learning Based Code Smell Detection Through WekaNose","U. Azadi; F. A. Fontana; M. Zanoni","Universita degli Studi di Milano-Bicocca, Milano, Lombardia, IT; Universita degli Studi di Milano-Bicocca, Milano, Lombardia, IT; Universita degli Studi di Milano-Bicocca, Milano, Lombardia, IT","2018 IEEE/ACM 40th International Conference on Software Engineering: Companion (ICSE-Companion)","30 Aug 2018","2018","","","288","289","Code smells can be subjectively interpreted, the results provided by detectors are usually different, the agreement in the results is scarce, and a benchmark for the comparison of these results is not yet available. The main approaches used to detect code smells are based on the computation of a set of metrics. However code smell detectors often use different metrics and/or different thresholds, according to their detection rules. As result of this inconsistency the number of detected smells can increase or decrease accordingly, and this makes hard to understand when, for a specific software, a certain characteristic identifies a code smell or not. In this work, we introduce WekaNose, a tool that allows to perform an experiment to study code smell detection through machine learning techniques. The experiment's purpose is to select rules, and/or obtain trained algorithms, that can classify an instance (method or class) as affected or not by a code smell. These rules have the main advantage of being extracted through an example-based approach, rather then a heuristic-based one.","2574-1934","978-1-4503-5663-3","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8449543","Code smell detection tool;Machine Learning techniques;Learning by examples;Community based detection","Software engineering","learning (artificial intelligence);software maintenance","detection rules;machine learning-based code smell detection;WekaNose","","","","","","30 Aug 2018","","","IEEE","IEEE Conferences"
"Improving Machine Learning-Based Code Smell Detection via Hyper-Parameter Optimization","L. Shen; W. Liu; X. Chen; Q. Gu; X. Liu","School of Computer Science and Technology, Nanjing Tech University, Nanjing, China; State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; School of Computer Science and Technology, Nanjing Tech University, Nanjing, China","2020 27th Asia-Pacific Software Engineering Conference (APSEC)","1 Mar 2021","2020","","","276","285","Unlike code errors, the presence of code smell often does not affect the behavior of the software system, but it will cause quality problems in terms of readability, understandability, and efficiency. To improve the software quality and reduce the maintenance costs, the developers need to detect code smells rapidly and make corresponding code refactoring. In code smell detection, recently, machine learning-based methods become more prevalent and can overcome the shortcomings of the heuristic-based methods, which mainly rely on manually designed rules. However, to our best knowledge, there is little research to analyze whether using hyper-parameter optimization can improve the performance of machine learning-based methods. In this study, we mainly focus on two classical code smells (i.e., Data Class and Feature Envy). First, we consider four optimizers for hyper-parameter optimization, and six commonly used classifiers for machine-learning-based methods. Second, we use AUC as the performance measure to evaluate the performance of constructed models. Based on final empirical results, we find that (1) Using hyper-parameter optimization can significantly improve the performance of code smell detection. (2) Differential evolution (DE) optimizer can achieve better performance than the other three optimizers when using the random forest classifier. (3) We can further improve the performance of code smell detection when performing parameter optimization on the DE optimizer.","2640-0715","978-1-7281-9553-7","10.1109/APSEC51365.2020.00036","National Natural Science Foundation of China(grant numbers:No.61972192); Natural Science Foundation of Jiangsu Province(grant numbers:BK20180695); State Key Laboratory for Novel Software Technology at Nanjing University(grant numbers:KFKT2018B17); Nantong Application Research Plan(grant numbers:JC2019106); Jiangsu Government Scholarship for Overseas Studies; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9359294","code smell detection;machine learning;hyperparameter optimization;differential evolution","Learning systems;Software quality;Maintenance engineering;Software systems;Optimization;Random forests;Software engineering","learning (artificial intelligence);optimisation;software maintenance;software metrics;software quality","machine learning-based code smell detection;hyper-parameter optimization;code errors;code refactoring;machine learning-based methods;heuristic-based methods","","","","44","IEEE","1 Mar 2021","","","IEEE","IEEE Conferences"
"SMURF: A SVM-based Incremental Anti-pattern Detection Approach","A. Maiga; N. Ali; N. Bhattacharya; A. Sabané; Y. -G. Guéhéneuc; E. Aimeur","Ptidej Team, École Polytechnique de Montréal, Canada; Ptidej Team, Soccer Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, Soccer Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, Soccer Laboratory, DGIGL, École Polytechnique de Montréal, Canada; Ptidej Team, École Polytechnique de Montréal, Canada; Heron Laboratory, DIRO, Université de Montréal, Canada","2012 19th Working Conference on Reverse Engineering","20 Dec 2012","2012","","","466","475","In current, typical software development projects, hundreds of developers work asynchronously in space and time and may introduce anti-patterns in their software systems because of time pressure, lack of understanding, communication, and-or skills. Anti-patterns impede development and maintenance activities by making the source code more difficult to understand. Detecting anti-patterns incrementally and on subsets of a system could reduce costs, effort, and resources by allowing practitioners to identify and take into account occurrences of anti-patterns as they find them during their development and maintenance activities. Researchers have proposed approaches to detect occurrences of anti-patterns but these approaches have currently four limitations: (1) they require extensive knowledge of anti-patterns, (2) they have limited precision and recall, (3) they are not incremental, and (4) they cannot be applied on subsets of systems. To overcome these limitations, we introduce SMURF, a novel approach to detect anti-patterns, based on a machine learning technique - support vector machines - and taking into account practitioners' feedback. Indeed, through an empirical study involving three systems and four anti-patterns, we showed that the accuracy of SMURF is greater than that of DETEX and BDTEX when detecting anti-patterns occurrences. We also showed that SMURF can be applied in both intra-system and inter-system configurations. Finally, we reported that SMURF accuracy improves when using practitioners' feedback.","2375-5369","978-0-7695-4891-3","10.1109/WCRE.2012.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6385142","Anti-pattern;program comprehension;program maintenance;empirical software engineering","Support vector machines;Accuracy;Measurement;Training;Maintenance engineering;Kernel","learning (artificial intelligence);program diagnostics;software development management;software maintenance;support vector machines","SMURF;SVM-based incremental antipattern detection approach;software development projects;maintenance activities;development activities;source code;machine learning technique;support vector machines;DETEX;BDTEX;intersystem configurations;intrasystem configurations","","55","","32","IEEE","20 Dec 2012","","","IEEE","IEEE Conferences"
"Automatic Metric Thresholds Derivation for Code Smell Detection","F. Arcelli Fontana; V. Ferme; M. Zanoni; A. Yamashita","Department of Informatics, Systems and Communication University of Milano-Bicocca, Milano, Italy; Faculty of Informatics, University of Lugano (USI), Switzerland; Department of Informatics, Systems and Communication University of Milano-Bicocca, Milano, Italy; Mesan AS, Oslo, Norway","2015 IEEE/ACM 6th International Workshop on Emerging Trends in Software Metrics","6 Aug 2015","2015","","","44","53","Code smells are archetypes of design shortcomings in the code that can potentially cause problems during maintenance. One known approach for detecting code smells is via detection rules: a combination of different object-oriented metrics with pre-defined threshold values. The usage of inadequate thresholds when using this approach could lead to either having too few observations (too many false negatives) or too many observations (too many false positives). Furthermore, without a clear methodology for deriving thresholds, one is left with those suggested in literature (or by the tool vendors), which may not necessarily be suitable to the context of analysis. In this paper, we propose a data-driven (i.e., Benchmark-based) method to derive threshold values for code metrics, which can be used for implementing detection rules for code smells. Our method is transparent, repeatable and enables the extraction of thresholds that respect the statistical properties of the metric in question (such as scale and distribution). Thus, our approach enables the calibration of code smell detection rules by selecting relevant systems as benchmark data. To illustrate our approach, we generated a benchmark dataset based on 74 systems of the Qualitas Corpus, and extracted the thresholds for five smell detection rules.","2327-0969","978-1-4673-7103-2","10.1109/WETSoM.2015.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7181590","Metric thresholds;Code smell detection;Benchmark dataset","Measurement;Benchmark testing;Couplings;Complexity theory;Surgery;Electronic mail;Context","software maintenance;software metrics","automatic metric threshold derivation;code smell detection rules;software maintenance;object-oriented metrics;threshold values;false negatives;false positives;data-driven method;benchmark-based method;code metrics;threshold extraction;statistical properties;benchmark dataset;Qualitas Corpus","","20","2","35","IEEE","6 Aug 2015","","","IEEE","IEEE Conferences"
"Comparing Heuristic and Machine Learning Approaches for Metric-Based Code Smell Detection","F. Pecorelli; F. Palomba; D. Di Nucci; A. De Lucia","University of Salerno, Italy; University of Zurich, Switzerland; Vrije Universiteit Brussel, Belgium; University of Salerno, Italy","2019 IEEE/ACM 27th International Conference on Program Comprehension (ICPC)","29 Aug 2019","2019","","","93","104","Code smells represent poor implementation choices performed by developers when enhancing source code. Their negative impact on source code maintainability and comprehensibility has been widely shown in the past and several techniques to automatically detect them have been devised. Most of these techniques are based on heuristics, namely they compute a set of code metrics and combine them by creating detection rules; while they have a reasonable accuracy, a recent trend is represented by the use of machine learning where code metrics are used as predictors of the smelliness of code artefacts. Despite the recent advances in the field, there is still a noticeable lack of knowledge of whether machine learning can actually be more accurate than traditional heuristic-based approaches. To fill this gap, in this paper we propose a large-scale study to empirically compare the performance of heuristic-based and machine-learning-based techniques for metric-based code smell detection. We consider five code smell types and compare machine learning models with DECOR, a state-of-the-art heuristic-based approach. Key findings emphasize the need of further research aimed at improving the effectiveness of both machine learning and heuristic approaches for code smell detection: while DECOR generally achieves better performance than a machine learning baseline, its precision is still too low to make it usable in practice.","2643-7171","978-1-7281-1519-1","10.1109/ICPC.2019.00023","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8813271","Code Smells Detection;Heuristics;Machine Learning;Empirical Study","","learning (artificial intelligence);software maintenance;software metrics;source code (software)","metric-based code smell detection;source code maintainability;code metrics;code artefacts;heuristic approach;machine learning approach;DECOR","","22","1","99","IEEE","29 Aug 2019","","","IEEE","IEEE Conferences"
"Identification of Code Smell Using Machine Learning","A. Jesudoss; S. Maneesha; T. Lakshmi naga durga","Department of Computer Science and Engineering, Sathyabama Institute of Science and Technology, Chennai, Tamil Nadu, India; Department of Computer Science and Engineering, Sathyabama Institute of Science and Technology, Chennai, Tamil Nadu, India; Department of Computer Science and Engineering, Sathyabama Institute of Science and Technology, Chennai, Tamil Nadu, India","2019 International Conference on Intelligent Computing and Control Systems (ICCS)","16 Apr 2020","2019","","","54","58","Code smells are used to improve the quality of the software. Code smell detection detects the code problems like long method, large class, lazy class, long parameter list, feature envy, primitive obsession detector and too many literal detectors present in the code. In this work, two algorithms are used namely Support Vector Machine (SVM) and Random Forest algorithm. Support Vector Machine acts as classifier and the Random Forest algorithm are used for predicting the range of data. Decision making technique is used to identify the various problems present in the code. Code smell detection is a testing tool and it is mainly used by the developers, when the size of the code becomes unmanageable for manual detection. It also identifies deeper problems like syntax error, runtime error. It gives the output by analyzing the code in six different modules in this work.","","978-1-5386-8113-8","10.1109/ICCS45141.2019.9065317","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9065317","Code Smell;Bloated Code Detector;Lazy Class Detector;Feature Envy;Large Class;Long method;Primitive Obsession Detector;Bad Smells","Detectors;Feature extraction;Support vector machines;Software;Java;Conferences;Classification algorithms","decision making;learning (artificial intelligence);random forests;software maintenance;software quality","random forest algorithm;code smell detection;manual detection;machine learning;lazy class;primitive obsession detector;literal detectors;support vector machine;software quality;decision making","","1","","30","IEEE","16 Apr 2020","","","IEEE","IEEE Conferences"
"Detecting patterns and antipatterns in software using Prolog rules","A. Stoianov; I. Şora","Department of Computers, Politehnica University of Timisoara, Timisoara, Romania; Department of Computers, Politehnica University of Timisoara, Timisoara, Romania","2010 International Joint Conference on Computational Cybernetics and Technical Informatics","21 Jun 2010","2010","","","253","258","Program comprehension is a key prerequisite for the maintainance and analysis of legacy software systems. Knowing about the presence of design patterns or antipatterns in a software system can significantly improve the program comprehension. Unfortunately, in many cases the usage of certain patterns is seldom explicitly described in the software documentation, while antipatterns are never described as such in the documentation. Since manual inspection of the code of large software systems is difficult, automatic or semi-automatic procedures for discovering patterns and antipatterns from source code can be very helpful. In this article we propose detection methods for a set of patterns and antipatterns, using a logic-based approach. We define with help of Prolog predicates both structural and behavioural aspects of patterns and antipatters. The detection results obtained for a number of test systems are also presented.","","978-1-4244-7433-2","10.1109/ICCCYB.2010.5491288","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5491288","design pattern;antipattern;detection","Software systems;Documentation;Software maintenance;Vocabulary;Pattern analysis;Inspection;System testing;Software quality;Context;Computer architecture","pattern classification;PROLOG;software maintenance","software pattern detection;software antipattern detection;Prolog rules;program comprehension;legacy software systems;software maintenance;software analysis;logic-based approach","","13","","12","IEEE","21 Jun 2010","","","IEEE","IEEE Conferences"
"An Empirical Framework for Code Smell Prediction using Extreme Learning Machine","H. Gupta; L. Kumar; L. B. M. Neti","BITS Pilani Hyderabad Campus, India; BITS Pilani Hyderabad Campus, India; BITS Pilani Hyderabad Campus, India","2019 9th Annual Information Technology, Electromechanical Engineering and Microelectronics Conference (IEMECON)","21 Oct 2019","2019","","","189","195","The software containing code smells indicates the violation of standard design and coding practices by developer during the development of the software system. Recent empirical studies observed that classes having code smells have higher probability of change proneness or fault proneness with respect to classes having no code smells [1]. The effort of removing bugs due to code smells increases exponentially if the smells are not identified during the earlier phases of software development. The code smell prediction using source code metrics can be used in starting phases of software development life cycle to reduce the maintenance and testing effort of software and also help in improving the quality of the software. The work in this paper empirically investigates and evaluates different classification techniques, feature selection techniques, and data sampling techniques to handle imbalance data in predicting 7 different types of code smell. The conclusion of this research is assessed over 629 application packages. The experimental finding confirms the estimating capability of different classifiers, feature selection, and data imbalance techniques for developing code smell prediction models. Our analysis also reveals that the models developed using one technique are superior than the models developed using other techniques.","","978-1-5386-9325-4","10.1109/IEMECONX.2019.8877082","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8877082","Code Smell;Software Engineering;Source Code Metrics;Machine Learning;Feature selection","Measurement;Analytical models;Codes;Predictive models;Feature extraction;Software systems;Software","feature selection;feedforward neural nets;pattern classification;program debugging;program testing;software fault tolerance;software maintenance;software metrics;software quality;source code (software)","coding practices;source code metrics;software development life cycle;code smell prediction models;extreme learning machine;change proneness;fault proneness;bugs removal;software maintenance;software testing;software quality;classification techniques;feature selection techniques;data sampling techniques;data imbalance techniques","","3","","10","IEEE","21 Oct 2019","","","IEEE","IEEE Conferences"
"An empirical analysis of the distribution of unit test smells and their impact on software maintenance","G. Bavota; A. Qusef; R. Oliveto; A. De Lucia; D. Binkley","University of Salerno, Fisciano, (SA), Italy; University of Salerno, Fisciano, (SA), Italy; University of Molise, Pesche, (IS), Italy; University of Salerno, Fisciano, (SA), Italy; Loyola University Maryland, Baltimore, USA","2012 28th IEEE International Conference on Software Maintenance (ICSM)","10 Jan 2013","2012","","","56","65","Unit testing represents a key activity in software development and maintenance. Test suites with high internal quality facilitate maintenance activities, such as code comprehension and regression testing. Several guidelines have been proposed to help developers write good test suites. Unfortunately, such rules are not always followed resulting in the presence of bad test code smells (or simply test smells). Test smells have been defined as poorly designed tests and their presence may negatively affect the maintainability of test suites and production code. Despite the many studies that address code smells in general, until now there has been no empirical evidence regarding test smells (i) distribution in software systems nor (ii) their impact on the maintainability of software systems. This paper fills this gap by presenting two empirical studies. The first study is an exploratory analysis of 18 software systems (two industrial and 16 open source) aimed at analyzing the distribution of test smells in source code. The second study, a controlled experiment involving twenty master students, is aimed at analyzing whether the presence of test smells affects the comprehension of source code during software maintenance. The results show that (i) test smells are widely spread throughout the software systems studied and (ii) most of the test smells have a strong negative impact on the comprehensibility of test suites and production code.","1063-6773","978-1-4673-2312-3","10.1109/ICSM.2012.6405253","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6405253","Test smells;Unit testing;Mining software repositories;Controlled experiments","Testing;Software systems;Fixtures;Software maintenance;Maintenance engineering;Conferences","program testing;public domain software;software maintenance","empirical analysis;unit test smell distribution;software maintenance;software development;maintenance activity;code comprehension;regression testing;bad test code smell;test suite maintainability;production code;software system maintainability;industrial software;open source software;source code","","71","","24","IEEE","10 Jan 2013","","","IEEE","IEEE Conferences"
"Comparison of Machine Learning Methods for Code Smell Detection Using Reduced Features","K. Karađuzović-Hadžiabdić; R. Spahić","Faculty of Engineering andNatural Sciences, International University of Sarajevo, Sarajevo, Bosnia and Herzegovina; Equinor ASA Research Center Trondheim Rotvoll, Norway","2018 3rd International Conference on Computer Science and Engineering (UBMK)","9 Dec 2018","2018","","","670","672","We examine a machine learning approach for detecting common Class and Method level code smells (Data Class and God Class, Feature Envy and Long Method). The focus of the work is selection of reduced set of features that will achieve high classification accuracy. The proposed features may be used by the developers to develop better quality software since the selected features focus on the most critical parts of the code that is responsible for creation of common code smells. We obtained a high accuracy results for all four code smells using the selected features: 98.57% for Data Class, 97.86% for God Class, 99.67% for Feature Envy, and 99.76% for Long Method.","","978-1-5386-7893-0","10.1109/UBMK.2018.8566561","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8566561","code smells;machine learning;feature selection","Machine learning;Feature extraction;Conferences;Software maintenance;Software engineering","learning (artificial intelligence);pattern classification;programming;software quality;source code (software)","Data Class;God Class;Feature Envy;Long Method;code smell detection;reduced features;machine learning;software quality","","1","","10","IEEE","9 Dec 2018","","","IEEE","IEEE Conferences"
"Support vector machines for anti-pattern detection","A. Maiga; N. Ali; N. Bhattacharya; A. Sabané; Y. -G. Guéhéneuc; G. Antoniol; E. Aïmeur","Université de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; École Polytechnique de Montréal, QUE, Canada; Université de Montréal, QUE, Canada","2012 Proceedings of the 27th IEEE/ACM International Conference on Automated Software Engineering","8 Apr 2013","2012","","","278","281","Developers may introduce anti-patterns in their software systems because of time pressure, lack of understanding, communication, and--or skills. Anti-patterns impede development and maintenance activities by making the source code more difficult to understand. Detecting anti-patterns in a whole software system may be infeasible because of the required parsing time and of the subsequent needed manual validation. Detecting anti-patterns on subsets of a system could reduce costs, effort, and resources. Researchers have proposed approaches to detect occurrences of anti-patterns but these approaches have currently some limitations: they require extensive knowledge of anti-patterns, they have limited precision and recall, and they cannot be applied on subsets of systems. To overcome these limitations, we introduce SVMDetect, a novel approach to detect anti-patterns, based on a machine learning technique---support vector machines. Indeed, through an empirical study involving three subject systems and four anti-patterns, we showed that the accuracy of SVMDetect is greater than of DETEX when detecting anti-patterns occurrences on a set of classes. Concerning, the whole system, SVMDetect is able to find more anti-patterns occurrences than DETEX.","","978-1-4503-1204-2","10.1145/2351676.2351723","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6494935","Anti-pattern;empirical software engineering;program comprehension;program maintenance","","learning (artificial intelligence);software maintenance;support vector machines","support vector machines;antipattern detection;software systems;source code;parsing time;manual validation;SVMDetect;machine learning technique;DETEX","","22","","13","","8 Apr 2013","","","IEEE","IEEE Conferences"
"Improving Design Smell Detection for Adoption in Industry","K. Alkharabsheh; J. A. Taboada; Y. Crespo; T. Alzu'bi","CiTIUS, Centro Singular de Investigacion en Tecnologias de la Informacion Universidade de Santiago de Compostela Santiago, de Compostela, Spain; CiTIUS, Centro Singular de Investigacion en Tecnologias de la Informacion Universidade de Santiago de Compostela Santiago, de Compostela, Spain; CiTIUS, Centro Singular de Investigacion en Tecnologias de la Informacion Universidade de Santiago de Compostela Santiago, de Compostela, Spain; CiTIUS, Centro Singular de Investigacion en Tecnologias de la Informacion Universidade de Santiago de Compostela Santiago, de Compostela, Spain","2018 8th International Conference on Computer Science and Information Technology (CSIT)","11 Oct 2018","2018","","","213","218","This work deals with the development of a classification algorithm that will improve the usefulness of design smell detection tools for its adoption in industry in order to increase software quality (maintainability, understandability, etc.). The current knowledge of Design Smell Detection (types of smells, approaches, strategies, algorithms, tools, etc.) will be identified. After that, a dataset that allow the comparison of different machine learning techniques will be developed. Analysis of possible improvements derived of the introduction of subjectivity, adaptability and gray scale are also an objective of the work.","","978-1-5386-4152-1","10.1109/CSIT.2018.8486180","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8486180","Design Smell;Detection Tools;Machine Learning;Software Quality;Empirical Study","Tools;Software quality;Measurement;Software algorithms;Java;Machine learning algorithms","learning (artificial intelligence);pattern classification;software quality","classification algorithm;design smell detection tools;software quality;improving design smell detection;adoption industry;machine learning techniques","","1","","28","EU","11 Oct 2018","","","IEEE","IEEE Conferences"
"An Empirical Analysis on the Role of WSDL Metrics in Web Service Anti-Pattern Prediction","S. Tummalapalli; L. Kumar; L. B. M. Neti; A. Krishna","BITS-Pilani, Hyderabad; BITS-Pilani, Hyderabad; BITS-Pilani, Hyderabad; Curtin University, Australia","2020 IEEE 22nd International Conference on High Performance Computing and Communications; IEEE 18th International Conference on Smart City; IEEE 6th International Conference on Data Science and Systems (HPCC/SmartCity/DSS)","26 Apr 2021","2020","","","559","564","Service-Oriented Architecture (SOA) is one of the most well-known models for designing web systems. SOA system evolution and maintenance is challenging because of its distributive nature and secondly due to the demand of designing high-quality, stable interfaces. This evolution leads to a problem called Anti-patterns in web services. It is observed that these anti-patterns negatively impact the evolution and maintenance of software systems, making the early detection and correction of them a primary concern for the software developers. The primary motivation of this work is to investigate the relationship between the Web Service Description Language(WSDL) metrics and anti-patterns in web services. This research aims to develop an automatic method for the detection of web service anti-patterns. The core idea of the methodology defined is to identify the most crucial WSDL metrics with the association of various feature selection techniques for the prediction of anti-patterns. Experimental results show that the model developed by using all the WSDL quantity metrics(AM) shows a bit high performance compared to the models developed with the other metric sets. Experimental results also showed that the performance of the models generated using Decision Tree(DT) and Major Voting Ensemble(MVE) is high compared to the models generated using other classifier techniques.","","978-1-7281-7649-9","10.1109/HPCC-SmartCity-DSS50907.2020.00070","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9407977","Anti-patterns;Web Services;WSDL metrics;Neural Networks;Feature Selection;Data Sampling;Machine Learning","Measurement;Computational modeling;High performance computing;Conferences;Maintenance engineering;Software systems;Feature extraction","decision trees;service-oriented architecture;software maintenance;software metrics;software quality;user interfaces;Web services","Web service anti-pattern prediction;SOA system evolution;Web systems design;software system maintenance;WSDL metrics;service oriented architecture;SOA system maintenance;software developers;Web service description language metrics;feature selection;decision tree;major voting ensemble","","","","7","IEEE","26 Apr 2021","","","IEEE","IEEE Conferences"
"Bad-smell prediction from software design model using machine learning techniques","N. Maneerat; P. Muenchaisri","Department of Computer Engineering, Faculty of Engineering, Chulalongkom University, Bangkok, Thailand; Department of Computer Engineering, Faculty of Engineering, Chulalongkom University, Bangkok, Thailand","2011 Eighth International Joint Conference on Computer Science and Software Engineering (JCSSE)","23 Jun 2011","2011","","","331","336","Bad-smell prediction significantly impacts on software quality. It is beneficial if bad-smell prediction can be performed as early as possible in the development life cycle. We present methodology for predicting bad-smells from software design model. We collect 7 data sets from the previous literatures which offer 27 design model metrics and 7 bad-smells. They are learnt and tested to predict bad-smells using seven machine learning algorithms. We use cross-validation for assessing the performance and for preventing over-fitting. Statistical significance tests are used to evaluate and compare the prediction performance. We conclude that our methodology have proximity to actual values.","","978-1-4577-0687-5","10.1109/JCSSE.2011.5930143","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5930143","Bad-smell;Software Design Model;Random Forest;Design Diagram Metrics;Prediction models;Machine Learners","","learning (artificial intelligence);software maintenance;software metrics;software quality;statistical analysis","bad-smell prediction;software design model;machine learning;software quality;statistical significance test","","29","","14","IEEE","23 Jun 2011","","","IEEE","IEEE Conferences"
"Antipattern and Code Smell False Positives: Preliminary Conceptualization and Classification","F. A. Fontana; J. Dietrich; B. Walter; A. Yamashita; M. Zanoni","Department of Informatics, Systems and Communication, University of Milano-Bicocca, Milano, Italy; School of Engineering and Advanced Technology, Massey University, Palmerston North, New Zealand; Faculty of Computing, Poznań University of Technology, Poznań, Poland; Department of Information Technology, Oslo and Akershus University, Oslo, Norway; Department of Informatics, Systems and Communication, University of Milano-Bicocca, Milano, Italy","2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)","23 May 2016","2016","1","","609","613","Anti-patterns and code smells are archetypes used for describing software design shortcomings that can negatively affect software quality, in particular maintainability. Tools, metrics and methodologies have been developed to identify these archetypes, based on the assumption that they can point at problematic code. However, recent empirical studies have shown that some of these archetypes are ubiquitous in real world programs, and many of them are found not to be as detrimental to quality as previously conjectured. We are therefore interested in revisiting common anti-patterns and code smells, and building a catalogue of cases that constitute candidates for ""false positives"". We propose a preliminary classification of such false positives with the aim of facilitating a better understanding of the effects of anti-patterns and code smells in practice. We hope that the development and further refinement of such a classification can support researchers and tool vendors in their endeavour to develop more pragmatic, context-relevant detection and analysis tools for anti-patterns and code smells.","","978-1-5090-1855-0","10.1109/SANER.2016.84","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476682","Anti-patterns;code smells;false positives;detection accuracy;conceptual framework","Production facilities;Generators;Software quality;Graphical user interfaces;Maintenance engineering;Systematics;Concrete","pattern classification;software maintenance;software reliability;ubiquitous computing","code smells;software design shortcomings;software quality;software maintainability;false positives;tool vendors;context-relevant detection;antipattern analysis tools;preliminary classification;preliminary conceptualization","","40","","34","IEEE","23 May 2016","","","IEEE","IEEE Conferences"
"A Metric-Based Heuristic Framework to Detect Object-Oriented Design Flaws","M. Salehie; Shimin Li; L. Tahvildari","Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada; Department of Electrical and Computer Engineering, University of Waterloo, Waterloo, ONT, Canada","14th IEEE International Conference on Program Comprehension (ICPC'06)","26 Jun 2006","2006","","","159","168","One of the important activities in re-engineering process is detecting design flaws. Such design flaws prevent an efficient maintenance, and further development of a system. This research proposes a novel metric-based heuristic framework to detect and locate object-oriented design flaws from the source code. It is accomplished by evaluating design quality of an object-oriented system through quantifying deviations from good design heuristics and principles. While design flaws can occur at any level, the proposed approach assesses the design quality of internal and external structure of a system at the class level which is the most fundamental level of a system. In a nutshell, design flaws are detected and located systematically in two phases using a generic OO design knowledge-base. In the first phase, hotspots are detected by primitive classifiers via measuring metrics indicating a design feature (e.g. complexity). In the second phase, individual design flaws will be detected by composite classifiers using a proper set of metrics. We have chosen JBoss Application Server as the case study, due to its pure OO large size structure, and its success as an open source J2EE platform among developers.","1092-8138","0-7695-2601-2","10.1109/ICPC.2006.6","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1631118","","Phase detection;Software systems;Process design;Phase measurement;Application software;Open source software;Software design;Medical diagnosis;Medical expert systems;Diagnostic expert systems","object-oriented programming;program debugging;software maintenance;software metrics;software quality;systems re-engineering","software re-engineering;software maintenance;metric-based heuristic framework;object-oriented design flaw detection;source code;design quality;knowledge-base;JBoss application server;open source J2EE platform","","21","","23","IEEE","26 Jun 2006","","","IEEE","IEEE Conferences"
"Predicting maintainability of open source software using Gene Expression Programming and bad smells","S. Tarwani; A. Chug","University School of Information and Communication Technology, Guru Gobind Singh Indraprastha University, New Delhi, India; University School of Information and Communication Technology, Guru Gobind Singh Indraprastha University, New Delhi, India","2016 5th International Conference on Reliability, Infocom Technologies and Optimization (Trends and Future Directions) (ICRITO)","19 Dec 2016","2016","","","452","459","Software maintenance phase of Software Development Lifecycle (SDLC) is the most expensive and complex phase that requires nearly 60-70% of the total project cost. Due to this, many software fails to get repair within real time constraint. Ascribe to technology advancements and changing requirements, software must be well developed and maintained to get adapted. Hence, it is necessary to predict software maintainability in the early phases of the lifecycle so that optimization of resources can be possible and cost can be reduced. Software Maintainability is the quality attribute of software product that explains the ease with which modifications can be performed. The main focus in this study is to propose the use of Gene Expression Programming (GEP) for the software maintainability prediction and measure its performance with various machine leaning techniques such as Decision Tree Forest, Support Vector Machine, Linear regression, Multilayer Perceptron and Radial basis function neural network. The empirical study is conducted with the help of four open source datasets. Eleven bad smells are identified and is considered as maintenance effort. Results of this study show that GEP algorithm performs better than machine learning classifiers; hence it can be used as sound alternative in the prediction of software maintainability. This study would be helpful in achieving better resource allocation hence it will be useful for developers and maintainers.","","978-1-5090-1489-7","10.1109/ICRITO.2016.7784998","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7784998","Software Maintainability;Bad smell;Gene Expression Programming;Machine learning algorithm;Prediction accuracy measures;Software Metrics","Software;Measurement;Predictive models;Machine learning algorithms;Prediction algorithms;Software algorithms;Gene expression","evolutionary computation;learning (artificial intelligence);pattern classification;public domain software;software maintenance;software metrics","open source software;gene expression programming;bad smells;software maintenance;software development lifecycle;SDLC;software maintainability prediction;software product;machine learning classifiers;software metrics","","4","","25","IEEE","19 Dec 2016","","","IEEE","IEEE Conferences"
"Assessment of Code Smell for Predicting Class Change Proneness Using Machine Learning","N. Pritam; M. Khari; L. Hoang Son; R. Kumar; S. Jha; I. Priyadarshini; M. Abdel-Basset; H. Viet Long","Leading Pseudo Code Labs, Delhi, India; Department of Computer Science and Engineering, AIACTR, New Delhi, India; College of Electronics and Information Engineering, Sejong University, Seoul, South Korea; Department of Computer Science and Engineering, LNCT College, Jabalpur, India; School of Computer Engineering, KIIT University, Bhubaneswar, India; Department of Electrical and Computer Engineering, University of Delaware, Newark, DE, USA; Department of Operations Research and Decision Support, Zagazig University, Zagazig, Egypt; Faculty of Mathematics and Statistics, Ton Duc Thang University, Ho Chi Minh City, Vietnam","IEEE Access","1 Apr 2019","2019","7","","37414","37425","Assessment of code smell for predicting software change proneness is essential to ensure its significance in the area of software quality. While multiple studies have been conducted in this regard, the number of systems studied and the methods used in this paper are quite different, thus, causing confusion for understanding the best methodology. The objective of this paper is to approve the effect of code smell on the change inclination of a specific class in a product framework. This is the novelty and surplus of this work against the others. Furthermore, this paper aims to validate code smell for predicting class change proneness to find an error in the prediction of change proneness using code smell. Six typical machine learning algorithms (Naive Bayes Classifier, Multilayer Perceptron, LogitBoost, Bagging, Random Forest, and Decision Tree) have been used to predict change proneness using code smell from a set of 8200 Java classes spanning 14 software systems. The experimental results suggest that code smell is indeed a powerful predictor of class change proneness with multilayer perceptron being the most effective technique. The sensitivity and specificity values for all the models are well over 70% with a few exceptions.","2169-3536","","10.1109/ACCESS.2019.2905133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8667419","Code smell;change proneness;software maintenance;machine learning;multilayer perceptron","Machine learning;Measurement;Machine learning algorithms;Multilayer perceptrons;Software systems;Tools","Bayes methods;decision trees;Java;learning (artificial intelligence);multilayer perceptrons;pattern classification;software maintenance;software quality","code smell;software systems;Java classes;decision tree;random forest;bagging;LogitBoost;multilayer perceptron;naive Bayes classifier;machine learning algorithms;class change proneness;software change proneness","","24","","29","OAPA","14 Mar 2019","","","IEEE","IEEE Journals"
"An Empirical Framework for Web Service Anti-pattern Prediction using Machine Learning Techniques","S. Tummalapalli; L. Kumar; L. B. M. Neti","BITS Pilani Hyderabad Campus, India; BITS Pilani Hyderabad Campus, India; BITS Pilani Hyderabad Campus, India","2019 9th Annual Information Technology, Electromechanical Engineering and Microelectronics Conference (IEMECON)","21 Oct 2019","2019","","","137","143","In todays software industries, the concepts of Web Services are applied to design and develop distributed software system. These distributed software system can be designed and developed by integrating different Web Services provided by different parties. Similar to other software systems, Web Services based system also suffers from bad or poor design i.e., bad design selection, anti-pattern, poor planning etc.. Early prediction of anti-patterns can help developer and tester in fixing design issue and also effectively utilize the resources. The work in this paper empirically investigates and evaluates six classification techniques, 8 feature selection techniques (7 feature ranking techniques and 1 feature subset evaluation technique), and 1 data sampling technique to handle imbalance data in predicting 5 different types of anti-patterns. These all techniques are validated on 226 real-world web-services across several domains. The performance of the developed models using these techniques are evaluated using AUC value. Our analysis reveals that the model developed using these techniques able to predict different anti-patterns using source code metrics. Our analysis also reveals that the best feature selection technique is OneR, data sample is better that without sampling and Random Forest is best classification algorithm for anti-pattern predictions.","","978-1-5386-9325-4","10.1109/IEMECONX.2019.8877008","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8877008","Anti-Patterns;Software Engineering;Source Code Metrics;Web Services;Machine Learning;Feature selection;Aggregation Measures","Measurement;Web services;Feature extraction;Predictive models;Tools;Software systems","data handling;distributed processing;DP industry;feature extraction;feature selection;learning (artificial intelligence);pattern classification;software metrics;Web services","machine learning;software industries;distributed software system;Web services;software systems;feature selection;data sampling;feature selection technique;Web service antipattern prediction;AUC value;source code metrics","","4","","18","IEEE","21 Oct 2019","","","IEEE","IEEE Conferences"
"Comparison of Multi-Label Classification Algorithms for Code Smell Detection","E. O. Kiyak; D. Birant; K. U. Birant","The Graduate School of Natural and Applied Sciences, Dokuz Eylul University, Izmir, Turkey; Department of Computer Engineering, Dokuz Eylul University, Izmir, Turkey; Department of Computer Engineering, Dokuz Eylul University, Izmir, Turkey","2019 3rd International Symposium on Multidisciplinary Studies and Innovative Technologies (ISMSIT)","16 Dec 2019","2019","","","1","6","Code smells in a source code shows the weakness of design or implementation. To detect code smells, several detection tools have been developed. However, these tools generally produce different results, since code smells are subjectively interpreted, informally defined and configured by the developers, domain-dependent and based on opinions and experiences. To cope with these issues, in this paper, we have used machine learning techniques, especially multi-label classification methods, to classify whether the given source code is affected with more than one code smells or not. We have conducted experiments on four code smell datasets and transformed them into two multi-label datasets (one for method level and the other one for class level). Two multi-label classification methods (Classifier Chains and Label Combination) and their ensemble models performed on the converted datasets using five different base classifiers. The results show that, as a base classifier, Random Forest algorithm performs better than Decision Tree, Naive Bayes, Support Vector Machine and Neural Network algorithms.","","978-1-7281-3789-6","10.1109/ISMSIT.2019.8932855","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8932855","code smell detection;multi-label classification;software engineering;machine learning","Classification algorithms;Machine learning;Support vector machines;Tools;Machine learning algorithms;Software algorithms;Decision trees","decision trees;learning (artificial intelligence);pattern classification;support vector machines","code smell datasets;multilabel datasets;multilabel classification methods;code smell detection;detection tools;source code;classifier chains;label combination;base classifiers;random forest algorithm","","1","","16","IEEE","16 Dec 2019","","","IEEE","IEEE Conferences"
"Do We Have a Chance to Fix Bugs When Refactoring Code Smells?","W. Ma; L. Chen; Y. Zhou; B. Xu","State Key Laboratory for Novel Software Technology Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology Nanjing University, Nanjing, China; State Key Laboratory for Novel Software Technology Nanjing University, Nanjing, China","2016 International Conference on Software Analysis, Testing and Evolution (SATE)","12 Dec 2016","2016","","","24","29","Code smells are used to describe code structures that may cause detrimental effects on software and should be refactored. Previous studies show that some code smells have significant effect on faults. However, how to refactor code smells to reduce bugs still needs more concern. We investigate the possibility of prioritizing code smell refactoring with the help of fault prediction results. We also investigate the possibility of improving the performance of fault prediction by using code smell detection results. We use Cohen's Kappa statistic to report agreements between results of code smell detections and fault predictions. We use fault prediction result as an indicator to guide code smell refactoring. Our results show that refactoring Blob, Long Parameter List, and Refused Parent Be Request may have a good chance to detect and fix bugs, and some code smells are particularly useful for improving the recall of fault prediction.","","978-1-5090-4517-4","10.1109/SATE.2016.11","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7780189","Code smell;refactoring;refactoring prioritization;fault prediction","Computer bugs;Measurement;Software;Object oriented modeling;Predictive models;Complexity theory;Logistics","program debugging;software fault tolerance;software maintenance;software performance evaluation","bugs;code structures;code smell detection;Kappa statistic;code smell refactoring;Refused Parent Be Request;Long Parameter List;Blob;fault prediction performance improvement","","9","","35","IEEE","12 Dec 2016","","","IEEE","IEEE Conferences"
"Antipattern-Based Problem Injection for Assessing Performance and Reliability Evaluation Techniques","P. Keck; A. Van Hoorn; D. Okanović; T. Pitakrat; T. F. Düllmann","Inst. of Software Technol., University of Stuttgart, Stuttgart, Germany; Inst. of Software Technol., Universitat Stuttgart, Stuttgart, Baden-WÃ¼rttemberg, DE; Inst. of Software Technol., University of Stuttgart, Stuttgart, Germany; Inst. of Software Technol., University of Stuttgart, Stuttgart, Germany; Inst. of Software Technol., University of Stuttgart, Stuttgart, Germany","2016 IEEE International Symposium on Software Reliability Engineering Workshops (ISSREW)","19 Dec 2016","2016","","","64","70","A challenging problem with today's increasingly large and distributed software systems is their performance behavior. To help developers avoid or detect mistakes that lead to performance problems, many researchers in software performance engineering have come up with classifications of such problems, called antipatterns. To test the approaches for antipattern detection, data from running systems is required. However, the usefulness of this data is doubtful as it may or may not include manifestations of performance problems. In this paper, we classify existing performance antipatterns w.r.t. their suitability for being injected and, based on this, introduce an extensible tool that allows to inject instances of these antipatterns into existing applications. The approach can be useful for researchers to test and validate their automated runtime problem evaluation and prevention techniques. Using two exemplary performance antipatterns, it is demonstrated that the injection is easily possible and produces feasible, though currently rather clinical results.","","978-1-5090-3601-1","10.1109/ISSREW.2016.36","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7789382","performance antipatterns;problem injection;performance and reliability evaluation","Libraries;Bridges;Instruments;Software reliability;Software systems","distributed processing;pattern classification;software performance evaluation;software reliability","anti pattern-based problem injection;performance evaluation technique;reliability evaluation technique;distributed software systems;performance behavior;software performance engineering;anti pattern detection;automated runtime problem evaluation technique;automated runtime prevention technique","","5","","47","IEEE","19 Dec 2016","","","IEEE","IEEE Conferences"
"Keep it simple: Is deep learning good for linguistic smell detection?","S. Fakhoury; V. Arnaoudova; C. Noiseux; F. Khomh; G. Antoniol","School of Electrical Engineering and Computer Science, Washington State University, Pullman, USA; School of Electrical Engineering and Computer Science, Washington State University, Pullman, USA; Department of Computer and Software Engineering, Polytechnique Montréal, Montréal, Canada; Department of Computer and Software Engineering, Polytechnique Montréal, Montréal, Canada; Department of Computer and Software Engineering, Polytechnique Montréal, Montréal, Canada","2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)","5 Apr 2018","2018","","","602","611","Deep neural networks is a popular technique that has been applied successfully to domains such as image processing, sentiment analysis, speech recognition, and computational linguistic. Deep neural networks are machine learning algorithms that, in general, require a labeled set of positive and negative examples that are used to tune hyper-parameters and adjust model coefficients to learn a prediction function. Recently, deep neural networks have also been successfully applied to certain software engineering problem domains (e.g., bug prediction), however, results are shown to be outperformed by traditional machine learning approaches in other domains (e.g., recovering links between entries in a discussion forum). In this paper, we report our experience in building an automatic Linguistic Antipattern Detector (LAPD) using deep neural networks. We manually build and validate an oracle of around 1,700 instances and create binary classification models using traditional machine learning approaches and Convolutional Neural Networks. Our experience is that, considering the size of the oracle, the available hardware and software, as well as the theory to interpret results, deep neural networks are outperformed by traditional machine learning algorithms in terms of all evaluation metrics we used and resources (time and memory). Therefore, although deep learning is reported to produce results comparable and even superior to human experts for certain complex tasks, it does not seem to be a good fit for simple classification tasks like smell detection. Researchers and practitioners should be careful when selecting machine learning models for the problem at hand.","","978-1-5386-4969-5","10.1109/SANER.2018.8330265","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8330265","Antipattern Detection;Machine Learning;Con-volutional Neural Networks","Neural networks;Machine learning;Support vector machines;Linguistics;Task analysis;Machine learning algorithms;Vegetation","computational linguistics;convolution;feedforward neural nets;learning (artificial intelligence);pattern classification","deep neural networks;Convolutional Neural Networks;machine learning models;deep learning;linguistic smell detection;prediction function;automatic Linguistic Antipattern Detector;binary classification models","","8","","29","IEEE","5 Apr 2018","","","IEEE","IEEE Conferences"
"Evaluating Domain-Specific Metric Thresholds: An Empirical Study","A. Mori; G. Vale; M. Viggiato; J. Oliveira; E. Figueiredo; E. Cirilo; P. Jamshidi; C. Kastner","Computer Science Department, Federal University of Minas Gerais (UFMG), Belo Horizonte, Brazil; Department of Informatics and Mathematics, University of Passau, Passau, Germany; Computer Science Department, Federal University of Minas Gerais (UFMG), Belo Horizonte, Brazil; Computer Science Department, Pontifical Catholic University of Minas Gerais (PUC-Minas), Belo Horizonte, Brazil; Computer Science Department, Federal University of Minas Gerais (UFMG), Belo Horizonte, Brazil; Computer Science Department, Federal University of Sao Joao del-Rei (UFSJ), Sao Joao del-Rei, Brazil; Institute for Software Research, Carnegie Mellon University (CMU), Pittsburgh, United States; Institute for Software Research, Carnegie Mellon University (CMU), Pittsburgh, United States","2018 IEEE/ACM International Conference on Technical Debt (TechDebt)","30 Dec 2018","2018","","","41","50","Software metrics and thresholds provide means to quantify several quality attributes of software systems. Indeed, they have been used in a wide variety of methods and tools for detecting different sorts of technical debts, such as code smells. Unfortunately, these methods and tools do not take into account characteristics of software domains, as the intrinsic complexity of geo-localization and scientific software systems or the simple protocols employed by messaging applications. Instead, they rely on generic thresholds that are derived from heterogeneous systems. Although derivation of reliable thresholds has long been a concern, we still lack empirical evidence about threshold variation across distinct software domains. To tackle this limitation, this paper investigates whether and how thresholds vary across domains by presenting a large-scale study on 3,107 software systems from 15 domains. We analyzed the derivation and distribution of thresholds based on 8 well-known source code metrics. As a result, we observed that software domain and size are relevant factors to be considered when building benchmarks for threshold derivation. Moreover, we also observed that domain-specific metric thresholds are more appropriated than generic ones for code smell detection.","","978-1-4503-5713-5","","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8595098","Software metrics;thresholds;software domains","Benchmark testing;Software metrics;Software systems;Tools","software maintenance;software metrics;software quality","source code metrics;software thresholds;technical debts;geo-localization;messaging applications;reliable thresholds;heterogeneous systems;generic thresholds;scientific software systems;software metrics;code smell detection;domain-specific metric thresholds;threshold derivation;software domain;threshold variation","","6","","35","","30 Dec 2018","","","IEEE","IEEE Conferences"
"Are Smell-Based Metrics Actually Useful in Effort-Aware Structural Change-Proneness Prediction? An Empirical Study","H. Liu; Y. Yu; B. Li; Y. Yang; R. Jia","School of Computer Science and Engineering, Southeast University, Nanjing, China; Centre for Research in Computing, The Open University, UK; School of Computer Science and Engineering, Southeast University, Nanjing, China; State Key Laboratory for Novel Software Technology, Nanjing University, Nanjing, China; School of Software and Electrical Engineering, Swinburne University of Technology, Melbourne, Australia","2018 25th Asia-Pacific Software Engineering Conference (APSEC)","23 May 2019","2018","","","315","324","Bad code smells (also named as code smells) are symptoms of poor design choices in implementation. Existing increases the likelihood of subsequent changes (i.e., change-proness). However, to the best of our knowledge, no prior studies have leveraged smell-based metrics to predict particular change type (i.e., structural changes). Moreover, when evaluating the effectiveness of smell-based metrics in structural change-proneness prediction, none of existing studies take into account of the effort inspecting those change-prone source code. In this paper, we consider five smell-based metrics for effort-aware structural change-proneness prediction and compare these metrics with a baseline of well-known CK metrics in predicting particular categories of change types. Specifically, we first employ univariate logistic regression to analyze the correlation between each smell-based metric and structural change-proneness. Then, we build multivariate prediction models to examine the effectiveness of smell-based metrics in effort-aware structural change-proneness prediction when used alone and used together with the baseline metrics, respectively. Our experiments are conducted on six Java open-source projects with up to 60 versions and results indicate that: (1) all smell-based metrics are significantly related to structural change-proneness, except metric ANOS in hive and SCM in camel after removing confounding effect of file size; (2) in most cases, smell-based metrics outperform the baseline metrics in predicting structural change-proneness; and (3) when used together with the baseline metrics, the smell-based metrics are more effective to predict change-prone files with being aware of inspection effort.","2640-0715","978-1-7281-1970-0","10.1109/APSEC.2018.00046","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8719536","code smell;structual change;effort-aware;change-proneness prediction","Measurement;Tools;Predictive models;Java;Software;Data collection;Logistics","Java;public domain software;regression analysis;software maintenance;software metrics;software quality","effort-aware structural change-proneness prediction;change-prone source code;baseline metrics;smell-based metrics;univariate logistic regression;multivariate prediction models;Java open-source projects;change-prone files","","1","","37","IEEE","23 May 2019","","","IEEE","IEEE Conferences"
"Deep Learning Anti-Patterns from Code Metrics History","A. Barbez; F. Khomh; Y. -G. Guéhéneuc","Polytechnique Montreal, Canada; Polytechnique Montreal, Canada; Concordia University, Montreal, QC, Canada","2019 IEEE International Conference on Software Maintenance and Evolution (ICSME)","5 Dec 2019","2019","","","114","124","Anti-patterns are poor solutions to recurring design problems. Number of empirical studies have highlighted the negative impact of anti-patterns on software maintenance which motivated the development of various detection techniques. Most of these approaches rely on structural metrics of software systems to identify affected components while others exploit historical information by analyzing co-changes occurring between code components. By relying solely on one aspect of software systems (i.e., structural or historical), existing approaches miss some precious information which limits their performances. In this paper, we propose CAME (Convolutional Analysis of code Metrics Evolution), a deep-learning based approach that relies on both structural and historical information to detect anti-patterns. Our approach exploits historical values of structural code metrics mined from version control systems and uses a Convolutional Neural Network classifier to infer the presence of anti-patterns from this information. We experiment our approach for the widely know God Class anti-pattern and evaluate its performances on three software systems. With the results of our study, we show that: (1) using historical values of source code metrics allows to increase the precision; (2) CAME outperforms existing static machine-learning classifiers; and (3) CAME outperforms existing detection tools.","2576-3148","978-1-7281-3094-1","10.1109/ICSME.2019.00021","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8919037","Anti-patterns;Deep learning;Mining Software Repositories","Measurement;History;Software systems;Machine learning;Feature extraction;Open source software;Software maintenance","convolutional neural nets;data mining;learning (artificial intelligence);pattern classification;software maintenance;software metrics;software performance evaluation;software quality","historical values;structural code metrics;anti-patterns;God Class anti-pattern;software systems;source code metrics;structural metrics;historical information;code components;code Metrics Evolution;deep-learning based approach","","2","","40","IEEE","5 Dec 2019","","","IEEE","IEEE Conferences"
"Design Flaws Prediction for Impact on Software Maintainability using Extreme Learning Machine","P. Thongkum; S. Mekruksavanich","Department of Software Engineering, University of Phayao, Phayao, Thailand; Department of Computer Engineering, University of Phayao, Phayao, Thailand","2020 Joint International Conference on Digital Arts, Media and Technology with ECTI Northern Section Conference on Electrical, Electronics, Computer and Telecommunications Engineering (ECTI DAMT & NCON)","11 May 2020","2020","","","79","82","The software that contains flaws in its design is an indication that the design and coding standards have been violated by the developer during the software system’s development. It has been observed in recent empirical studies that classes with flaws in the design flaws have a higher probability of change proneness or fault proneness when compared to classes without flaws in the design. There is an exponential increase in terms of the effort required to remove bugs due to design flaws in cases where the flaws are not detected in the early stages of the development of the software. The use of source code metrics for the prediction of design flaws can be implemented in the initial stages of the life cycle of the software development for the reduction of the testing effort and the maintenance of the software as well as the improvement of its quality. This empirical research study examines and assesses a variety of techniques for classification, feature selection, and data sampling in order to deal with the imbalance data for prediction of several categories of design flaws. The assessment of more than 20 application packages is the basis of the conclusions of this study. The results of the experiments indicate that the estimating capability of various classifiers, feature selection, and data imbalance techniques for the development of prediction models for design flaws can be confirmed. In addition, it was also revealed that the models that were developed through the use of one particular technique were found to be superior to the models that were developed with the use of other techniques, according to our analysis.","","978-1-7281-6398-7","10.1109/ECTIDAMTNCON48261.2020.9090717","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9090717","design flaws;Extreme Learning Machine;software metrics;software maintenance","Predictive models;Kernel;Computational modeling;Software metrics;Neurons","learning (artificial intelligence);pattern classification;probability;program debugging;software maintenance;software metrics;software quality","software system;design flaw prediction;feature selection;data imbalance techniques;design standard;coding standard;extreme learning machine;software development life cycle;software quality;classification;data sampling;software maintainability","","","","13","IEEE","11 May 2020","","","IEEE","IEEE Conferences"
"Do Code Smells Impact the Effort of Different Maintenance Programming Activities?","Z. Soh; A. Yamashita; F. Khomh; Y. -G. Guéhéneuc","Department of Computer and Software Engineering, Polytechnique de Montreal; Department of Information Technology, Oslo and Akershus University, Oslo, Norway; Department of Computer and Software Engineering, Polytechnique de Montreal; Department of Computer and Software Engineering, Polytechnique de Montreal","2016 IEEE 23rd International Conference on Software Analysis, Evolution, and Reengineering (SANER)","23 May 2016","2016","1","","393","402","Empirical studies have shown so far that code smells have relatively low impact over maintenance effort at file level. We surmise that previous studies have found low effects of code smells because the effort considered is a ""sheer-effort"" that does not distinguish between the kinds of developers' activities. In our study, we investigate the effects of code smells at the activity level. Examples of activities are: reading, editing, searching, and navigating, which are performed independently over different files during maintenance. We conjecture that structural attributes represented in the form of different code smells do indeed have an effect on the effort for performing certain kinds of activities. To verify this conjecture, we revisit a previous study about the impact of code smell on maintenance effort, using the same dataset, but considering activity effort. Six professional developers were hired to perform three maintenance tasks on four functionally equivalent Java Systems. Each developer performs two maintenance tasks. During maintenance task, we monitor developers' logs. Then, we define an annotation schema to identify developers' activities and assess whether code smells affect different maintenance activities. Results show that different code smells affect differently activity effort. Yet, the size of the changes performed to solve the task impacts the effort of all activities more than code smells and file size. While code smells impact the editing and navigating effort more than file size, the file size impacts the reading and searching activities more than code smells. One major implication of these results is that if code smells indeed affect the effort of certain kinds of activities, it means that their effects are contingent on the type of maintenance task at hand, where some kinds of activities will become more predominant than others.","","978-1-5090-1855-0","10.1109/SANER.2016.103","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7476660","code smells;programming activity;maintenance effort;program comprehension;software quality","Maintenance engineering;Navigation;Java;Programming;Software;Companies;Software engineering","file organisation;Java;software maintenance;software quality","maintenance programming activities;code smells;file level;structural attributes;maintenance effort;functionally equivalent Java systems;developer log monitoring;annotation schema;file size","","25","","40","IEEE","23 May 2016","","","IEEE","IEEE Conferences"
"Code Smell Detection: Towards a Machine Learning-Based Approach","F. A. Fontana; M. Zanoni; A. Marino; M. V. Mäntylä","Department of Informatics, Systems and Communication University of Milano-Bicocca, Milano, Italy; Department of Informatics, Systems and Communication University of Milano-Bicocca, Milano, Italy; Department of Informatics, Systems and Communication University of Milano-Bicocca, Milano, Italy; Aalto University, Helsinki, Finland","2013 IEEE International Conference on Software Maintenance","2 Dec 2013","2013","","","396","399","Several code smells detection tools have been developed providing different results, because smells can be subjectively interpreted and hence detected in different ways. Usually the detection techniques are based on the computation of different kinds of metrics, and other aspects related to the domain of the system under analysis, its size and other design features are not taken into account. In this paper we propose an approach we are studying based on machine learning techniques. We outline some common problems faced for smells detection and we describe the different steps of our approach and the algorithms we use for the classification.","1063-6773","978-0-7695-4981-1","10.1109/ICSM.2013.56","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6676916","code smells detection;machine learning techniques","Measurement;Machine learning algorithms;Detectors;Software;Conferences;Labeling;Accuracy","learning (artificial intelligence);pattern classification;program diagnostics","code smell detection tools;machine learning-based approach;classification","","94","","20","IEEE","2 Dec 2013","","","IEEE","IEEE Conferences"
"AdaBoost-based Refused Bequest Code Smell Detection with Synthetic Instances","H. Chen; Z. Ren; L. Qiao; Z. Zhou; G. Gao; Y. Ma; H. Jiang","School of Software, Dalian University of Technology, Dalian, China; School of Software, Dalian University of Technology, Dalian, China; Beijing Institute of Control Engineering, Beijing, China; School of Software, Dalian University of Technology, Dalian, China; School of Software, Dalian University of Technology, Dalian, China; Taiyuan University of Technology, Taiyuan, China; School of Software, Dalian University of Technology, Dalian, China","2020 7th International Conference on Dependable Systems and Their Applications (DSA)","26 Jan 2021","2020","","","78","89","Software requirements are constantly changing. Consequently, the development process is frequently under time pressure, which results in technical debt. To illustrate the symptoms of technical debt, 22 code smells have been introduced to indicate the poor design in code fragment, among which refused bequest is one of the most harmful smells and with high diffuseness. However, refused bequest is rarely taken into account because there is a lack of dataset. Moreover, it is difficult to design the detection rules for refused bequest compared with other popular smells. In this paper, we propose a machine-learning-based refused bequest smell detection framework SEADART, which features the utilization of a set of synthetic smelly instances. Specifically, SEADART comprises three components: (1) a smell generation approach, and (2) a model training strategy, and (3) an AdaBoost-based detection model. We evaluate the performance of the proposed framework. The evaluation results suggest that the generated smelly instances are reliable, and the trained AdaBoost model significantly outperforms the state-of-the-art over a real-world dataset.","","978-0-7381-2422-3","10.1109/DSA51864.2020.00019","Research and Development; National Natural Science Foundation of China; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9331242","Technical Debt;Code Smell;Refused Bequest;AdaBoost","Measurement;Training;Java;Machine learning;Feature extraction;Software;Reliability","learning (artificial intelligence);software maintenance","code fragment;detection rules;machine learning;smell generation approach;AdaBoost-based detection model;trained AdaBoost model;synthetic instances;software requirements;technical debt;refused bequest code smell detection;SEADART","","","","29","IEEE","26 Jan 2021","","","IEEE","IEEE Conferences"
"An adaptive approach for automatic design defects detection in object-oriented systems","S. Mekruksavanich","Department of Computer Engineering, University of Phayao, Phayao, Thailand","2017 International Conference on Digital Arts, Media and Technology (ICDAMT)","24 Apr 2017","2017","","","342","346","Design defects in object-oriented software have a detrimental impact on quality and also increase maintenance costs. Timeous detection and identification of these flaws is, therefore, necessary to avoid adverse outcomes within the system. Metric-based heuristic frameworks have recently become popular for detecting and locating object-oriented design defects from the source code. Imperfections can occur at any level and obtaining proper threshold values is often a complicated process. To lessen this impact, an adjustable threshold methodology for metric-based design flaw detection was proposed through machine learning to compute the contribution and threshold values of each metric set. The threshold values were adjusted and adapted to conform to the software data input characteristics. Results demonstrated that the proposed method generated more appropriate threshold limits for the detection of design imperfections. Implementation was simple, less time-consuming and did not require expert knowledge compared to traditional procedures.","","978-1-5090-5210-3","10.1109/ICDAMT.2017.7904988","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7904988","Design flaws;Defect detection;Machine learning;Software metric","Neurons;Training;Maintenance engineering;Software systems;Software metrics","learning (artificial intelligence);object-oriented methods;software reliability","contribution value;threshold value;machine learning;metric-based design flaw detection;adjustable threshold methodology;metric-based heuristic frameworks;object-oriented software;object-oriented systems;automatic design defects detection","","1","","26","IEEE","24 Apr 2017","","","IEEE","IEEE Conferences"
"A Support Vector Machine Based Approach for Code Smell Detection","A. Kaur; S. Jain; S. Goel","Department of Computer Science and Engineering, Thapar University, Patiala, Punjab, India; Department of Computer Science and Engineering, Thapar University, Patiala, Punjab, India; Department of Computer Science and Engineering, Bennett University, G. Noida, Uttar Pradesh, India","2017 International Conference on Machine Learning and Data Science (MLDS)","22 Mar 2018","2017","","","9","14","Code smells may be introduced in software due to market rivalry, work pressure deadline, improper functioning, skills or inexperience of software developers. Code smells indicate problems in design or code which makes software hard to change and maintain. Detecting code smells could reduce the effort of developers, resources and cost of the software. Many researchers have proposed different techniques like DETEX for detecting code smells which have limited precision and recall. To overcome these limitations, a new technique named as SVMCSD has been proposed for the detection of code smells, based on support vector machine learning technique. Four code smells are specified namely God Class, Feature Envy, Data Class and Long Method and the proposed technique is validated on two open source systems namely ArgoUML and Xerces. The accuracy of SVMCSD is found to be better than DETEX in terms of two metrics, precision and recall, when applied on a subset of a system. While considering the entire system, SVMCSD detect more occurrences of code smells than DETEX.","","978-1-5386-3446-2","10.1109/MLDS.2017.8","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8320252","Code smells;Anti-patterns;Support Vector Machine;Software maintenance","Support vector machines;Measurement;Software systems;Training;Software quality;Computer science","learning (artificial intelligence);public domain software;software maintenance;software metrics;software quality;support vector machines","support vector machine;software developers;code smell detection;code smells;DETEX;SVMCSD","","12","","21","IEEE","22 Mar 2018","","","IEEE","IEEE Conferences"
"Structural Quality Metrics as Indicators of the Long Method Bad Smell: An Empirical Study","S. Charalampidou; E. -M. Arvanitou; A. Ampatzoglou; P. Avgeriou; A. Chatzigeorgiou; I. Stamelos","Rijksuniversiteit Groningen, Groningen, Groningen, NL; Department of Computer Science, University of Macedonia, Thessaloniki, Greece; Rijksuniversiteit Groningen, Groningen, Groningen, NL; Rijksuniversiteit Groningen, Groningen, Groningen, NL; Department of Computer Science, University of Macedonia, Thessaloniki, Greece; Department of Computer Science, University of Macedonia, Thessaloniki, Greece","2018 44th Euromicro Conference on Software Engineering and Advanced Applications (SEAA)","21 Oct 2018","2018","","","234","238","Empirical evidence has pointed out that Extract Method refactorings are among the most commonly applied refactorings by software developers. The identification of Long Method code smells and the ranking of the associated refactoring opportunities is largely based on the use of metrics, primarily with measures of cohesion, size and coupling. Despite the relevance of these proper-ties to the presence of large, complex and non-cohesive pieces of code, the empirical validation of these metrics has exhibited relatively low accuracy (max precision: 66%) regarding their predictive power for long methods or extract method opportunities. In this work we perform an empirical validation of the ability of cohesion, coupling and size metrics to predict the existence and the intensity of long method occurrences. According to the statistical analysis, the existence and the intensity of the Long Method smell can be effectively predicted by two size (LoC and NoLV), two coupling (MPC and RFC), and four cohesion (LCOM1, LCOM2, Coh, and CC) metrics. Furthermore, the integration of these metrics into a multiple logistic regression model can predict whether a method should be refactored with a precision of 89% and a recall of 91%. The model yields suggestions whose ranking is strongly correlated to the ranking based on the effect of the corresponding refactorings on source code (correl. coef. 0.520). The results are discussed by providing interpretations and implications for research and practice.","","978-1-5386-7383-6","10.1109/SEAA.2018.00046","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8498213","long method;coupling;cohesion;size;case study","Measurement;Couplings;Software;Predictive models;Logistics;Informatics;Statistical analysis","regression analysis;software maintenance;software metrics","empirical validation;coupling;size metrics;long method occurrences;cohesion;multiple logistic regression model;source code;structural quality metrics;empirical evidence;software developers;proper-ties;max precision;predictive power;extract method refactorings;long method bad smell;long method code;extract method opportunities","","5","","26","IEEE","21 Oct 2018","","","IEEE","IEEE Conferences"
"A Bayesian Approach for the Detection of Code and Design Smells","F. Khomh; S. Vaucher; Y. -G. Guéhéneuc; H. Sahraoui","Ptidej Team DGIGL, Ecole Polytechnique de Montrèal, Canada; GEODES DIRO, Université de Montreal, Canada; Ptidej Team DGIGL, Ecole Polytechnique de Montrèal, Canada; GEODES DIRO, Université de Montreal, Canada","2009 Ninth International Conference on Quality Software","15 Jan 2010","2009","","","305","314","The presence of code and design smells can have a severe impact on the quality of a program. Consequently, their detection and correction have drawn the attention of both researchers and practitioners who have proposed various approaches to detect code and design smells in programs. However, none of these approaches handle the inherent uncertainty of the detection process. We propose a Bayesian approach to manage this uncertainty. First, we present a systematic process to convert existing state-of-the-art detection rules into a probabilistic model. We illustrate this process by generating a model to detect occurrences of the Blob antipattern. Second, we present results of the validation of the model: we built this model on two open-source programs, GanttProject v1.10.2 and Xerces v2.7.0, and measured its accuracy. Third, we compare our model with another approach to show that it returns the same candidate classes while ordering them to minimise the quality analysts' effort. Finally, we show that when past detection results are available, our model can be calibrated using machine learning techniques to offer an improved, context-specific detection.","2332-662X","978-1-4244-5913-1","10.1109/QSIC.2009.47","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5381430","code smells;design smells;bayesian belief networks;software quality","Bayesian methods;Uncertainty;Software quality;Open source software;Electronic mail;Context modeling;Machine learning;Impedance;Quality assessment;Software systems","belief networks;software quality;uncertainty handling","Bayesian approach;uncertainty handling;probabilistic model;Blob antipattern;open source program;GanttProject v1.10.2;Xerces v2.7.0;quality analysts effort;machine learning technique;context specific detection;program quality;code smell detection;design smell detection;detection rules","","118","","32","IEEE","15 Jan 2010","","","IEEE","IEEE Conferences"
"Quantifying the Effect of Code Smells on Maintenance Effort","D. I. K. Sjøberg; A. Yamashita; B. C. D. Anda; A. Mockus; T. Dybå","Department of Informatics, University of Oslo, Oslo, Norway; Department of Informatics, University of Oslo, Oslo, Norway; Department of Informatics, University of Oslo, Oslo, Norway; Avaya Laboratories Research, Basking Ridge, NJ, USA; Universitetet i Oslo, Oslo, NO","IEEE Transactions on Software Engineering","25 Jul 2013","2013","39","8","1144","1156","Context: Code smells are assumed to indicate bad design that leads to less maintainable code. However, this assumption has not been investigated in controlled studies with professional software developers. Aim: This paper investigates the relationship between code smells and maintenance effort. Method: Six developers were hired to perform three maintenance tasks each on four functionally equivalent Java systems originally implemented by different companies. Each developer spent three to four weeks. In total, they modified 298 Java files in the four systems. An Eclipse IDE plug-in measured the exact amount of time a developer spent maintaining each file. Regression analysis was used to explain the effort using file properties, including the number of smells. Result: None of the 12 investigated smells was significantly associated with increased effort after we adjusted for file size and the number of changes; Refused Bequest was significantly associated with decreased effort. File size and the number of changes explained almost all of the modeled variation in effort. Conclusion: The effects of the 12 smells on maintenance effort were limited. To reduce maintenance effort, a focus on reducing code size and the work practices that limit the number of changes may be more beneficial than refactoring code smells.","1939-3520","","10.1109/TSE.2012.89","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6392174","Maintainability;object-oriented design;product metrics;code churn","Maintenance engineering;Java;Software;Surgery;Time measurement;Context;Electronic mail","Java;regression analysis;software maintenance","code smell effect quantification;maintenance effort;maintainable code;maintenance tasks;Java systems;Java files;Eclipse IDE plug-in;regression analysis;file properties;refused bequest;file size;code size reduction;code smell refactoring","","201","","46","IEEE","21 Dec 2012","","","IEEE","IEEE Journals"
"A Method to Derive Metric Thresholds for Software Product Lines","G. A. D. Vale; E. M. L. Figueiredo","Department of Computer Science, Federal University of Minas Gerais (UFMG), Belo Horizonte, MG, Brazil; Department of Computer Science, Federal University of Minas Gerais (UFMG), Belo Horizonte, MG, Brazil","2015 29th Brazilian Symposium on Software Engineering","12 Nov 2015","2015","","","110","119","A software product line (SPL) is a set of software systems that share a common and variable set of components (features). Software metrics provide basic means to quantify several quality aspects of SPL components. However, the effectiveness of the SPL measurement process is directly dependent on the definition of reliable thresholds. If thresholds are not properly defined, it is difficult to actually know whether a given metric value indicates a potential problem in the component implementation. There are several methods to derive thresholds for software metrics. However, there is little understanding about their appropriateness for the context of SPLs. This paper aims to propose a method to derive thresholds in the SPL context. Our method is evaluated in terms of recall and precision using two code smells (God Class and Lazy Class) detection strategies. The evaluation of our method is performed based on a benchmark of 33 SPLs and the results were compared with a method (baseline) with the same purpose used in the context of SPLs (not proposed). The results show that our method has better recall when compared with baseline.","","978-1-4673-9272-3","10.1109/SBES.2015.9","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7328015","Metrics;Thresholds;Software Product Lines","Benchmark testing;Software metrics;Software systems;Context;Programming","object-oriented programming;software metrics;software product lines","software product lines;software systems;software metric threshold;software quality;SPL components;SPL measurement process;component implementation;recall value;precision value;God Class;Lazy Class;code smell detection strategy","","12","","37","IEEE","12 Nov 2015","","","IEEE","IEEE Conferences"
"Using Code Evolution Information to Improve the Quality of Labels in Code Smell Datasets","Y. Wang; S. Hu; L. Yin; X. Zhou","School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China; School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China; School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China; School of Data and Computer Science, Sun Yat-sen University, Guangzhou, China","2018 IEEE 42nd Annual Computer Software and Applications Conference (COMPSAC)","22 Jun 2018","2018","01","","48","53","Several approaches are proposed to detect code smells. A set of important approaches are based on machine learning algorithms, which require the code smells have been labeled in source codes as training data firstly. The common labeling approaches are based on manual or tools, but it is difficult for current approaches to get reliable large-scale datasets. In this paper, an approach using the evolution information of source codes is proposed to get large-scale and more reliable training datasets for detecting code smells based on machine learning algorithms. Our approach analyzes the evolving of the source code smells firstly labeled by a tool from the baseline version into the contrastive version of a software system, and then constructs training datasets based on those ""changed smells"". Experiments conducted on three open source software projects for detecting four types of code smells(which are Data Class, God Class, Brain Class and Brain Method) show that the models obtained by changed smells datasets have better performance on code smell detection than those obtained by unchanged smells datasets (with an average improvement rate of 7.8% and a maximum increase of 30%). The experiments results indicate that using the evolution information of source codes can construct more reliable training datasets for detecting code smells based on machine learning algorithms.","0730-3157","978-1-5386-2667-2","10.1109/COMPSAC.2018.00015","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8377639","Code smells;Training dataset;Machine learning;Refactoring","Tools;Training;Reliability;Java;Software;Machine learning algorithms;Labeling","learning (artificial intelligence);public domain software;software quality;source code (software)","code smell datasets;machine learning algorithms;source code;code evolution information;open source software project;software quality","","","","20","IEEE","22 Jun 2018","","","IEEE","IEEE Conferences"
"Detecting Code Smells using Deep Learning","A. K. Das; S. Yadav; S. Dhal","Department of Software Engineering, International Institute of Information Technology, Bangalore, India; Department of Computer Science and Engineering, Indian Institute of Information Technology, Guwahati, India; Department of Computer Science and Engineering, Indian Institute of Information Technology, Guwahati, India","TENCON 2019 - 2019 IEEE Region 10 Conference (TENCON)","12 Dec 2019","2019","","","2081","2086","A smell in software refers to a symptom introduced in software artifacts such as architecture, design or code. A code smell can potentially cause deeper and serious problems, while dealing with mainly non-functional requirements such as testability, maintainability, extensibility and scalability. The detection of code smell is an essential step in the refactoring process, which facilitates non functional requirements in a software. The existing approaches for detecting code smells use detection rules or standards using a combination of different object-oriented metrics. Although a variety of code smell detection tools have been developed, they still have limitations and constraints in their capabilities. The most well-known object-oriented metrics are considered to identify the presence of smells in software. This paper proposes a deep learning based approach to detect two code smells (Brain Class and Brain Method). The proposed system uses thirty open source Java projects, which are shared by many users in GitHub repositories. The dataset of these Java projects is partitioned into mutually exclusive training and test sets. Our experiments have demonstrated high accuracy results for both the code smells.","2159-3450","978-1-7281-1895-6","10.1109/TENCON.2019.8929628","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8929628","Code smells;Deep Learning;Object-oriented metrics;Code smell detection tools","Machine learning;Software;Measurement;Convolutional codes;Tools;Biological neural networks;Training","Java;learning (artificial intelligence);program testing;public domain software;software maintenance;software metrics;software quality","nonfunctional requirements;code smell detection tools;deep learning;software artifacts;refactoring process;open source Java projects;GitHub repositories;exclusive training sets;test sets","","4","","27","IEEE","12 Dec 2019","","","IEEE","IEEE Conferences"
"Code Bad Smell Detection through Evolutionary Data Mining","S. Fu; B. Shen","School of Software, Shanghai Jiao Tong University, Shanghai, China; School of Software, Shanghai Jiao Tong University, Shanghai, China","2015 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)","9 Nov 2015","2015","","","1","9","The existence of code bad smell has a severe impact on the software quality. Numerous researches show that ignoring code bad smells can lead to failure of a software system. Thus, the detection of bad smells has drawn the attention of many researchers and practitioners. Quite a few approaches have been proposed to detect code bad smells. Most approaches are solely based on structural information extracted from source code. However, we have observed that some code bad smells have the evolutionary property, and thus propose a novel approach to detect three code bad smells by mining software evolutionary data: duplicated code, shotgun surgery, and divergent change. It exploits association rules mined from change history of software systems, upon which we define heuristic algorithms to detect the three bad smells. The experimental results on five open source projects demonstrate that the proposed approach achieves higher precision, recall and F-measure.","1949-3789","978-1-4673-7899-4","10.1109/ESEM.2015.7321194","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7321194","","Software systems;History;Association rules;Surgery;Couplings","data mining;evolutionary computation;software quality;source code (software)","code bad smell detection;software quality;source code;software evolutionary data mining;duplicated code;shotgun surgery;divergent change","","19","","31","IEEE","9 Nov 2015","","","IEEE","IEEE Conferences"
"A Deep Learning Based Approach to Detect Code Clones","G. Li; Y. Tang; X. Zhang; B. Yi","National Innovation Institute of Defense Technology, Beijing, China; National Innovation Institute of Defense Technology, Beijing, China; National Innovation Institute of Defense Technology, Beijing, China; National Innovation Institute of Defense Technology, Beijing, China","2020 International Conference on Intelligent Computing and Human-Computer Interaction (ICHCI)","10 May 2021","2020","","","337","340","Code clone is a kind of code smells widely exists in practice. Such code smell may lead to serious problems, e.g., code redundancy and code inconsistency. To reduce the negative impact of code clones, researchers have proposed different approaches to detect and remove code clones. However, existing code clone detection approaches mostly rely on manually designed and fine-tuned heuristic rules. Such approaches cannot be exploited in different projects and the precision of them needs to improve further. To this end, this paper proposes a deep learning based approach to detect code clones by statically extracting syntactic features from the ASTs of source files. Evaluation results suggest that the proposed approach is effective in detecting code clones, its precision is around 90%.","","978-1-6654-2316-8","10.1109/ICHCI51889.2020.00078","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9424815","code clone;software quality;deep learning","Deep learning;Human computer interaction;Redundancy;Cloning;Syntactics;Programming;Benchmark testing","deep learning (artificial intelligence);software maintenance;software quality;source code (software)","deep learning;code clones detection;code smell;syntactic features extraction;ASTs","","","","30","IEEE","10 May 2021","","","IEEE","IEEE Conferences"
"Bellwethers: A Baseline Method for Transfer Learning","R. Krishna; T. Menzies","Department of Computer Science, North Carolina State University, Raleigh; Department of Computer Science, North Carolina State University, Raleigh","IEEE Transactions on Software Engineering","12 Nov 2019","2019","45","11","1081","1105","Software analytics builds quality prediction models for software projects. Experience shows that (a) the more projects studied, the more varied are the conclusions; and (b) project managers lose faith in the results of software analytics if those results keep changing. To reduce this conclusion instability, we propose the use of “bellwethers”: given N projects from a community the bellwether is the project whose data yields the best predictions on all others. The bellwethers offer a way to mitigate conclusion instability because conclusions about a community are stable as long as this bellwether continues as the best oracle. Bellwethers are also simple to discover (just wrap a for-loop around standard data miners). When compared to other transfer learning methods (TCA+, transfer Naive Bayes, value cognitive boosting), using just the bellwether data to construct a simple transfer learner yields comparable predictions. Further, bellwethers appear in many SE tasks such as defect prediction, effort estimation, and bad smell detection. We hence recommend using bellwethers as a baseline method for transfer learning against which future work should be compared.","1939-3520","","10.1109/TSE.2018.2821670","National Science Foundation(grant numbers:#1506586,#1302169); ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8329264","Transfer learning;defect prediction;bad smells;issue close time;effort estimation;prediction","Estimation;Software;Software engineering;Task analysis;Benchmark testing;Complexity theory;Analytical models","learning (artificial intelligence);project management;software maintenance;software quality","software analytics;quality prediction models;software projects;transfer learning methods;bellwether data","","23","","154","IEEE","2 Apr 2018","","","IEEE","IEEE Journals"
"A case study in object-oriented patterns identified during manual refactoring","B. S. Dillon","Dahlgren Division Virginia Tech, Naval Surface Warfare Center, Blacksburg, VA, USA","2016 IEEE 14th International Conference on Software Engineering Research, Management and Applications (SERA)","21 Jul 2016","2016","","","91","98","Software design patterns are often-repeated implementations that have been identified and cataloged. These are commonly seen as useful and good patterns to implement. Occasionally the term “anti-pattern” has been used to identify less-useful patterns that also appear regularly. The exact definition of an anti-pattern is somewhat subjective, and the term has even been applied to some recognized design patterns. This paper discusses four manual refactoring case studies where patterns were discovered and cataloged. Evidence observed in the source code is used to infer how these patterns evolved. Based on these findings, preventive development practices are suggested. Potential improvements to development tools and a new method for pattern classification are suggested as subjects for future work.","","978-1-5090-0809-4","10.1109/SERA.2016.7516133","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7516133","Software evolution;reverse engineering;software aging;software quality;refactoring;design patterns;anti-patterns","Pattern recognition;Aging;Context;Manuals;Software design;Maintenance engineering","object-oriented methods;pattern classification;software maintenance;source code (software)","object-oriented patterns;manual refactoring;software design patterns;antipattern;source code;pattern classification","","","","25","IEEE","21 Jul 2016","","","IEEE","IEEE Conferences"
"An Experience Report on Using Code Smells Detection Tools","F. A. Fontana; E. Mariani; A. Mornioli; R. Sormani; A. Tonello","Department of Computer Science, Universita of Milano Bicocca, Milano, Italy; Department of Computer Science, Universita of Milano Bicocca, Milano, Italy; NA; Department of Computer Science, Universita of Milano Bicocca, Milano, Italy; Department of Computer Science, Universita of Milano Bicocca, Milano, Italy","2011 IEEE Fourth International Conference on Software Testing, Verification and Validation Workshops","14 Jul 2011","2011","","","450","457","Detecting code smells in the code and consequently applying the right refactoring steps when necessary is very important to improve the quality of the code. Different tools have been proposed for code smell detection, each one characterized by particular features. The aim of this paper is to describe our experience on using different tools for code smell detection. We outline the main differences among them and the different results we obtained.","","978-0-7695-4345-1","10.1109/ICSTW.2011.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5954446","code smells;code smell detection toools;refactoring;quality code evaluation","Measurement;Benchmark testing;Java;Software;Feature extraction;Couplings;Surgery","software maintenance;software quality","code smell detection tool;refactoring step;code quality;software characteristic","","36","","21","IEEE","14 Jul 2011","","","IEEE","IEEE Conferences"
"Feature Envy Detection based on Bi-LSTM with Self-Attention Mechanism","H. Wang; J. Liu; J. Kang; W. Yin; H. Sun; H. Wang","Shanghai Key Laboratory of Trustworthy Computing, East China Normal University, Shanghai, China; Shanghai Key Laboratory of Trustworthy Computing, East China Normal University, Shanghai, China; China Aeronautical Radio Electronics Research Institute, Shanghai, China; China Aeronautical Radio Electronics Research Institute, Shanghai, China; Shanghai Key Laboratory of Trustworthy Computing, East China Normal University, Shanghai, China; China Aeronautical Radio Electronics Research Institute, Shanghai, China","2020 IEEE Intl Conf on Parallel & Distributed Processing with Applications, Big Data & Cloud Computing, Sustainable Computing & Communications, Social Computing & Networking (ISPA/BDCloud/SocialCom/SustainCom)","4 Jun 2021","2020","","","448","457","Code Smell refers to suboptimal or harmful structures in the source code that may impede the maintainability of software. It serves as an effective way to detect refactoring opportunities. As the most prevailing smell, Feature Envy and its detection has been deeply explored for many years, which produces massive automated detection methods. Nevertheless, the heuristic-based approach cannot reach a satisfying level, and the machine learning approach still needs further optimization. Recent advances in deep learning inspire the birth of deep learning based approach. In this paper, we define a simpler distance metric as numerical feature and we collect class name and method name as text feature. Then we leverage Bidirectional Long-Short Term Memory (Bi-LSTM) Network with self-attention mechanism to extract semantic distance information in the text part, and we adopt embedding technology to enhance the structure distance information in the numerical part. Combined with the two sophisticatedly designed modules and the final classification module, a more reliable and accurate model is presented. Experimental results on seven open-source Java projects show that our model significantly outperforms existing methods.","","978-1-6654-1485-2","10.1109/ISPA-BDCloud-SocialCom-SustainCom51426.2020.00082","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9444004","Code smell;Feature Envy Detection;Bi-LSTM;Self-Attention Mechanism","Measurement;Deep learning;Semantics;Reliability theory;Network architecture;Feature extraction;Reliability engineering","data mining;Java;learning (artificial intelligence);public domain software;software maintenance;software metrics","structure distance information;numerical part;seven open-source Java projects;Feature Envy detection;Code Smell;suboptimal structures;harmful structures;source code;refactoring opportunities;prevailing smell;massive automated detection methods;heuristic-based approach;satisfying level;text part;semantic distance information;self-attention mechanism;leverage Bidirectional Long-Short Term Memory;text feature;method name;class name;numerical feature;simpler distance metric;deep learning based approach","","1","","37","IEEE","4 Jun 2021","","","IEEE","IEEE Conferences"
"Detecting code smells using machine learning techniques: Are we there yet?","D. Di Nucci; F. Palomba; D. A. Tamburri; A. Serebrenik; A. De Lucia","University of Salerno, Italy; University of Zurich, Switzerland; Eindhoven University of Technology, The Netherlands; Eindhoven University of Technology, The Netherlands; University of Salerno, Italy","2018 IEEE 25th International Conference on Software Analysis, Evolution and Reengineering (SANER)","5 Apr 2018","2018","","","612","621","Code smells are symptoms of poor design and implementation choices weighing heavily on the quality of produced source code. During the last decades several code smell detection tools have been proposed. However, the literature shows that the results of these tools can be subjective and are intrinsically tied to the nature and approach of the detection. In a recent work the use of Machine-Learning (ML) techniques for code smell detection has been proposed, possibly solving the issue of tool subjectivity giving to a learner the ability to discern between smelly and non-smelly source code elements. While this work opened a new perspective for code smell detection, it only considered the case where instances affected by a single type smell are contained in each dataset used to train and test the machine learners. In this work we replicate the study with a different dataset configuration containing instances of more than one type of smell. The results reveal that with this configuration the machine learning techniques reveal critical limitations in the state of the art which deserve further research.","","978-1-5386-4969-5","10.1109/SANER.2018.8330266","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8330266","Code Smells;Machine Learning;Empirical Studies;Replication Study","Detectors;Measurement;Tools;Software systems;Training;Predictive models;Buildings","learning (artificial intelligence);software maintenance","machine learning techniques;produced source code;code smell detection;single type smell;ML techniques;source code elements","","63","","90","IEEE","5 Apr 2018","","","IEEE","IEEE Conferences"
"Application of Naïve Bayes classifiers for refactoring Prediction at the method level","R. Panigrahi; S. K. kuanar; L. Kumar","Department of Computer Science and Engineering, GIET University, Gunupur, Odisha; Department of Computer Science and Engineering, GIET University, Gunupur, Odisha; Department of Computer Science and Information Systems, BITS-PILANI, Hyderabad, Hyderabad","2020 International Conference on Computer Science, Engineering and Applications (ICCSEA)","3 Jul 2020","2020","","","1","6","Software refactoring is a technique of redesigning the existing code without changing its functionality in order to improve on code readability, code adherence, maintainability and portability. Recent years have witnessed the advancement of research in the field of improvement in code quality. The challenges involved in the field has attracted many software practitioners to identify methods or classes that need refactoring. We propose a model to predict refactoring candidates by Naïve Bayes classifiers (Gaussian, Multinomial and Bernoulli (GNB, MNB, BNB)) at method level refactoring in terms of AUC and Accuracy. Method level refactoring is carried out on data set from the Tera-Promise repository and then validated. Min-max normalization and Imbalancing techniques are then applied. Then using the Wilcoxon rank test, 8 sets of significant features are drawn out of 103 sets of input features.The experimental results on the performance of 3 Naïve Bayes classifiers shows that the Bernoulli Naïve Bayes classifier gives more accuracy as compared to the other two classifiers. Statistical tests applied on all features (AF) and significant features (SF), shows that significant features gives more accurate prediction than all features.","","978-1-7281-5830-3","10.1109/ICCSEA49143.2020.9132849","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=9132849","Software refactoring;code smell;naïve Bayes classifier","Meters;Computer science;Codes;Machine learning algorithms;Gaussian processes;Predictive models;Software","Bayes methods;pattern classification;software maintenance;software quality;source code (software)","Naïve Bayes classifiers;software refactoring;code readability;code adherence;code quality","","","","13","IEEE","3 Jul 2020","","","IEEE","IEEE Conferences"
"An improved behavioral matching for anti-pattern based abstract factory recommendation","N. Nahar; T. S. U. Mahmud; K. Sakib","Institute of Information Technology, University of Dhaka, Bangladesh; Dhaka University, Dhaka, Dhaka District, BD; Institute of Information Technology, University of Dhaka, Bangladesh","2016 5th International Conference on Informatics, Electronics and Vision (ICIEV)","1 Dec 2016","2016","","","35","40","For a developed project, Abstract Factory can be recommended using structural and behavioral matching between the defined anti-patterns and project code. This paper proposes a refinement of the existing behavioral matching technique, where all possible aspects of Abstract Factory behaviors are considered. This matching phase is enhanced by generating family matrix using conditional and action parse, and product type matrix using class association. Those two matrices are analysed to identify whether a pair of classes have the same product type. If no such matching is found, regeneration of family matrix by class wise parsing is done and again the matrices are analysed for recommending Abstract Factory. The approach is implemented in the form of a tool named Source code based Abstract Factory Pattern Recommender (SAFPR). The performance is justified by an experimental result analysis that showed, SAFPR is successful in Abstract Factory recommendation for all the dataset projects.","","978-1-5090-1269-5","10.1109/ICIEV.2016.7760115","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7760115","","Production facilities;Pattern matching;Software design;Switches;Recommender systems;Containers","pattern matching;program compilers;project management;software development management;source code (software)","improved behavioral matching;antipattern based abstract factory recommendation;structural matching;project code;abstract factory behaviors;family matrix;product type matrix;class association;class wise parsing;source code based abstract factory pattern recommender;SAFPR","","","","12","IEEE","1 Dec 2016","","","IEEE","IEEE Conferences"
"Toward Proactive Refactoring: An Exploratory Study on Decaying Modules","N. Sae-Lim; S. Hayashi; M. Saeki","School of Computing, Tokyo Institute of Technology, Tokyo, Japan; School of Computing, Tokyo Institute of Technology, Tokyo, Japan; School of Computing, Tokyo Institute of Technology, Tokyo, Japan","2019 IEEE/ACM 3rd International Workshop on Refactoring (IWoR)","19 Sep 2019","2019","","","39","46","Source code quality is often measured using code smell, which is an indicator of design flaw or problem in the source code. Code smells can be detected using tools such as static analyzer that detects code smells based on source code metrics. Further, developers perform refactoring activities based on the result of such detection tools to improve source code quality. However, such approach can be considered as reactive refactoring, i.e., developers react to code smells after they occur. This means that developers first suffer the effects of low quality source code (e.g., low readability and understandability) before they start solving code smells. In this study, we focus on proactive refactoring, i.e., refactoring source code before it becomes smelly. This approach would allow developers to maintain source code quality without having to suffer the impact of code smells. To support the proactive refactoring process, we propose a technique to detect decaying modules, which are non-smelly modules that are about to become smelly. We present empirical studies on open source projects with the aim of studying the characteristics of decaying modules. Additionally, to facilitate developers in the refactoring planning process, we perform a study on using a machine learning technique to predict decaying modules and report a factor that contributes most to the performance of the model under consideration.","","978-1-7281-2270-0","10.1109/IWoR.2019.00015","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8844415","code quality;code smell;refactoring","Teeth;Tools;Indexes;Software;Current measurement;Machine learning","learning (artificial intelligence);public domain software;software maintenance;software metrics;software quality;source code (software)","decaying modules;code smell;source code metrics;proactive refactoring process;open source projects;source code quality maintenance;machine learning technique","","3","","23","IEEE","19 Sep 2019","","","IEEE","IEEE Conferences"
"Bug Prediction Model using Code Smells","G. M. Ubayawardana; D. D. Karunaratna","University of Colombo School of Computing, No 35 Reid Avenue, Colombo, Sri Lanka; University of Colombo, Colombo, Western, LK","2018 18th International Conference on Advances in ICT for Emerging Regions (ICTer)","17 Jan 2019","2018","","","70","77","The term `Code Smells' was first coined in the book Refactoring: Improving the design of existing code by M Fowler in 1999. Code smells are poor design choices which have the potential to cause an error or failure in a computer program. The objective of this study is to use code smells as a candidate metric to build a bug prediction model. In this study we have built a bug prediction model using both source code metrics and code smell based metrics proposed in the literature. We used Naive Bayes, Random Forest and Logistic Regression as our candidate algorithms to build the model. We have trained our model against multiple versions of 13 different Java based open source projects. The trained model was used to predict bugs in a particular version of a project, within a particular project and among different projects. We were able to demonstrate, that code smell based metrics can significantly improve the accuracy of a bug prediction model when integrated with source code metrics. Random Forest algorithm based model showed higher accuracy within a version, within a project and among projects when compared to other algorithms.","2472-7598","978-1-5386-7352-2","10.1109/ICTER.2018.8615550","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8615550","code smells;bug prediction;source code metrics","Computer bugs;Measurement;Predictive models;Complexity theory;Computational modeling;Software systems","Bayes methods;Java;program debugging;public domain software;random forests;regression analysis;software metrics;source code (software)","bug prediction model;source code metrics;random forest;code smells;naive Bayes;logistic regression","","3","","23","IEEE","17 Jan 2019","","","IEEE","IEEE Conferences"
"Software Design Patterns Recommendation : A Systematic Literature Review","M. Z. Asghar; K. A. Alam; S. Javed","Deptarment of Computer Sciences, National University Fast, Islamabad, Pakistan; Deptarment of Computer Sciences, National University Fast, Islamabad, Pakistan; Deptarment of Computer Sciences, National University Fast, Islamabad, Pakistan","2019 International Conference on Frontiers of Information Technology (FIT)","13 Feb 2020","2019","","","167","1675","Design patterns are essential for development. It provides reusability, modularization, quality and consistency between design and implementation. Expert knowledge required for the selection of correct design patterns. Moreover, the recommendation of design patterns is an important task for software development. Many tools and techniques were proposed to recommend design patterns. The main objective of this research is to perform a systematic literature review based on Kitchenham guidelines. We have analyzed the studies with different perspectives: Study objective, validation, recommendation technique for design pattern and limitation of the study. We have considered the research publication from 2010 to 2019 and examined them on four electronic databases. A total of 22 studies are identified from 2010-2019 and classified them on predefined classification criteria. Overall research findings concluded that anti-pattern detection and selection and fuzzy technique are most widely used but still there is a research gap that exists from the recent 2-years. It was observed that the traditional and most practiced recommendation techniques are not used in software design patterns recommendation.","2334-3141","978-1-7281-6625-4","10.1109/FIT47737.2019.00040","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8991630","Pattern Selection, Pattern Detection, Design Patterns, Pattern Recommendation, Systematic Literature Review","","fuzzy set theory;pattern classification;software architecture;software quality;software reusability","design pattern;anti-pattern detection;software design patterns recommendation;systematic literature review;correct design patterns;software development;recommendation technique;fuzzy technique;predefined classification criteria","","2","","33","IEEE","13 Feb 2020","","","IEEE","IEEE Conferences"
"Reducing Subjectivity in Code Smells Detection: Experimenting with the Long Method","S. Bryton; F. Brito e Abreu; M. Monteiro","QUASAR / CITI / FCT, Universidade Nova de Lisboa, Caparica, Portugal; QUASAR / CITI / FCT, Universidade Nova de Lisboa, Caparica, Portugal; CITI / FCT, Universidade Nova de Lisboa, Caparica, Portugal","2010 Seventh International Conference on the Quality of Information and Communications Technology","3 Dec 2010","2010","","","337","342","Guidelines for refactoring are meant to improve software systems internal quality and are widely acknowledged as among software’s best practices. However, such guidelines remain mostly qualitative in nature. As a result, judgments on how to conduct refactoring processes remain mostly subjective and therefore non-automatable, prone to errors and unrepeatable. The detection of the Long Method code smell is an example. To address this problem, this paper proposes a technique to detect Long Method objectively and automatically, using a Binary Logistic Regression model calibrated by expert’s knowledge. The results of an experiment illustrating the use of this technique are reported.","","978-1-4244-8539-0","10.1109/QUATIC.2010.60","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5655669","Refactoring Process;Code Smells;Long Method;Binary Logistic Regression","Measurement;Correlation;Mathematical model;Predictive models;Complexity theory;Logistics;Training","expert systems;regression analysis;software maintenance;software reusability;systems software","code smells detection;software systems;refactoring processes;long method code smell;binary logistic regression model;expert knowledge","","13","","24","IEEE","3 Dec 2010","","","IEEE","IEEE Conferences"
"An Empirical Examination of the Relationship between Code Smells and Merge Conflicts","I. Ahmed; C. Brindescu; U. A. Mannan; C. Jensen; A. Sarma","School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA; School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA","2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)","11 Dec 2017","2017","","","58","67","Background: Merge conflicts are a common occurrence in software development. Researchers have shown the negative impact of conflicts on the resulting code quality and the development workflow. Thus far, no one has investigated the effect of bad design (code smells) on merge conflicts. Aims: We posit that entities that exhibit certain types of code smells are more likely to be involved in a merge conflict. We also postulate that code elements that are both ""smelly"" and involved in a merge conflict are associated with other undesirable effects (more likely to be buggy). Method: We mined 143 repositories from GitHub and recreated 6,979 merge conflicts to obtain metrics about code changes and conflicts. We categorized conflicts into semantic or non-semantic, based on whether changes affected the Abstract Syntax Tree. For each conflicting change, we calculate the number of code smells and the number of future bug-fixes associated with the affected lines of code. Results: We found that entities that are smelly are three times more likely to be involved in merge conflicts. Method-level code smells (Blob Operation and Internal Duplication) are highly correlated with semantic conflicts. We also found that code that is smelly and experiences merge conflicts is more likely to be buggy. Conclusion: Bad code design not only impacts maintainability, it also impacts the day to day operations of a project, such as merging contributions, and negatively impacts the quality of the resulting code. Our findings indicate that research is needed to identify better ways to support merge conflict resolution to minimize its effect on code quality.","","978-1-5090-4039-1","10.1109/ESEM.2017.12","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8170085","Code Smell;Merge Conflict;Empirical Analysis;Machine Learning","Software;Merging;Computer bugs;Tools;Software measurement;Semantics","data mining;program debugging;public domain software;software maintenance;software metrics","conflicting change;method-level code;semantic conflicts;code changes;code elements;resulting code quality;merge conflicts Background;code smells;conflict resolution;Bad code design","","19","","68","IEEE","11 Dec 2017","","","IEEE","IEEE Conferences"
"What if I Had No Smells?","D. Falessi; B. Russo; K. Mullen","Dept. of Computer Science and Software Engineering, California Polytechnic State University, San Luis Obispo, CA, USA; Faculty of Computer Science, Free University of Bozen-Bolzano, Bolzano, Italy, USA; Keymind A Division of Axiom Resource Management, Inc. Falls Church, VA, USA","2017 ACM/IEEE International Symposium on Empirical Software Engineering and Measurement (ESEM)","11 Dec 2017","2017","","","78","84","What would have happened if I did not have any code smell? This is an interesting question that no previous study, to the best of our knowledge, has tried to answer. In this paper, we present a method for implementing a what-if scenario analysis estimating the number of defective files in the absence of smells. Our industrial case study shows that 20% of the total defective files were likely avoidable by avoiding smells. Such estimation needs to be used with the due care though as it is based on a hypothetical history (i.e., zero number of smells and same process and product change characteristics). Specifically, the number of defective files could even increase for some types of smells. In addition, we note that in some circumstances, accepting code with smells might still be a good option for a company.","","978-1-5090-4039-1","10.1109/ESEM.2017.14","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8170087","code smells;machine learning;software estimation;technical debt","Tools;Maintenance engineering;Software;Logic gates;Estimation;History;Business","software maintenance;software quality","code smell;total defective files","","11","","36","IEEE","11 Dec 2017","","","IEEE","IEEE Conferences"
"Sniffing Android Code Smells: An Association Rules Mining-Based Approach","J. Rubin; A. N. Henniche; N. Moha; M. Bouguessa; N. Bousbia","University of Quebec in Montreal; Higher National School of Computer Science, Montreal, Canada - Algiers, Algeria; University of Quebec in Montreal; University of Quebec in Montreal; Higher National School of Computer Science, Montreal, Canada - Algiers, Algeria","2019 IEEE/ACM 6th International Conference on Mobile Software Engineering and Systems (MOBILESoft)","29 Aug 2019","2019","","","123","127","Interest in mobile applications (mobile apps) has grown significantly in recent years and has become an important part of the software development market. Indeed, mobile apps become more and more complex and evolve constantly, while their development time decreases. This complexity and time pressure might lead developers to adopt bad design and implementation choices, which are known as code smells. Code smells in mobile apps could lead to performance issues such as overconsumption of hardware resources (CPU, RAM, battery) or even downtime and crashes. Some tools have been proposed for the detection of code smells in Android apps, such as PAPRIKA or ADOCTOR tools. These tools rely on metrics-based detection rules, which are defined manually according to code smell definitions. However, manually defined rules might be inaccurate and subjective because they are based on user interpretations. In this paper, we present a tool-based approach, called FAKIE, which allows the automatic inference of detection rules by analysing code smells data using an association rules algorithm: FP-GROWTH. We validated FAKIE by applying it on a manually analysed validation dataset of 48 opensource mobile apps. We were able to generate detection rules for a dozen code smells, with an average F-measure of 0.95. After all of that, we performed an empirical study by applying FAKIE on 2,993 apps downloaded from ANDROZOO, a repository of mobile apps.","","978-1-7281-3395-9","10.1109/MOBILESoft.2019.00025","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=8816887","Android, code smells, detection, association rules, mobile applications","Measurement;Mobile applications;Tools;Software;Complexity theory;Manuals;Computer crashes","Android (operating system);data mining;mobile computing;software maintenance;source code (software)","dozen code;android code;association rules mining-based approach;mobile applications;software development market;Android apps;metrics-based detection rules;code smell definitions;manually defined rules;tool-based approach;code analysis;opensource mobile apps","","1","","33","IEEE","29 Aug 2019","","","IEEE","IEEE Conferences"
"Helping end users find and fix performance issues in visual dataflow code","C. Chambers","School of Electrical Engineering and Computer Science, Oregon State University, Corvallis, OR, USA","2013 IEEE Symposium on Visual Languages and Human Centric Computing","24 Oct 2013","2013","","","169","170","In this paper, the author discusses three techniques that will help end users find and fix performance problems in dataflow code. All of these techniques adapt the established concept of a “bad smell,” which is a heuristic for finding sections of code that function correctly but that have poor maintainability. This concept is adapted and applied in the context of visual dataflow languages for the novel purpose of helping them find and fix a broad range of performance problems. To test these techniques, we will create a prototype that applies them to LabVIEW. Using this prototype, we will conduct several user studies to evaluate how useful each technique is and how well they help end users to find and fix performance problems.","1943-6106","978-1-4799-0369-6","10.1109/VLHCC.2013.6645269","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=6645269","","Visualization;Prototypes;Software;Instruments;Computers;Arrays;Performance analysis","data flow analysis;software maintenance;software performance evaluation;visual languages;visual programming","performance problems;visual dataflow code;bad smell concept;maintainability;visual dataflow languages;LabVIEW","","","","11","IEEE","24 Oct 2013","","","IEEE","IEEE Conferences"
"Size and Frequency of Class Change from a Refactoring Perspective","S. Counsell; E. Mendes","Department of Information Systems and Computing, Brunei University, Uxbridge, Middlesex, UK; Department of Computer Science, University of Auckland, New Zealand","Third International IEEE Workshop on Software Evolvability 2007","12 Nov 2007","2007","","","23","28","A previous study by Bieman et al., investigated whether large, object-oriented classes were more susceptible to change than smaller classes. The measure of change used in the study was the frequency with which the features of a class had been changed over a specific period of time. From a refactoring perspective, the frequency of class change is of value But even for a relatively simple refactoring such as 'rename method', multiple classes may undergo minor modification without any net increase in class (and system) size. In this paper, we suggest that the combination of 'versions of a class and number of added lines of code ' in the bad code 'smell' detection process may give a better impression of which classes are most suitable candidates for refactoring; as such, effort in detecting bad code smells should apply to classes with a high growth rate as well as a high change frequency. To support our investigation, data relating to changes from 161 Java classes was collected. Results concluded that it is not necessarily the case that large classes are more change-prone than relatively smaller classes. Moreover, the bad code smell detection process is informed by using the combination of change frequency and class size as a heuristic.","","978-0-7695-3002-4","10.1109/SE.2007.13","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=4383093","Version;Refactoring;LOC.","Java;Lab-on-a-chip;Conferences;Information systems;Computer science;Frequency measurement;Time measurement;Data analysis;Software libraries;Software quality","Java;object-oriented programming","refactoring perspective;object-oriented classes;rename method;bad code smell detection;Java classes","","2","","18","IEEE","12 Nov 2007","","","IEEE","IEEE Conferences"
"H-RAFT - heuristic reachability analysis for fault tolerance protocols modelled in SDL","S. M. Bohm","University of Duisburg-Essen, Essen, Germany","2005 International Conference on Dependable Systems and Networks (DSN'05)","25 Jul 2005","2005","","","466","475","Design flaws of fault tolerance techniques may lead to undesired consequences in particular fault cases under very special operating conditions. Such rare ""fault tolerance holes"" may be very difficult to reveal. This paper presents a novel approach directing the analysis towards potential weaknesses in a fault tolerance technique. A new algorithm based on special heuristics performs partial reachability analysis of SDL models describing fault-tolerant communication. It aims at finding violations of fault tolerance properties in an efficient way. The approach does not require knowledge of the model under investigation. The new algorithm is evaluated by experiments with realistic protocols - including a large model of an industrial system - and compared to the performance of known solutions.","2158-3927","0-7695-2282-3","10.1109/DSN.2005.53","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=1467821","","Reachability analysis;Fault tolerance;Protocols;State-space methods;Safety;Automata;Tree graphs;Formal verification;Hardware;Testing","fault tolerant computing;program testing;protocols;formal verification;specification languages;reachability analysis","heuristic reachability analysis;fault tolerance technique;protocol;SDL;specification and description language;design flaw","","","","20","IEEE","25 Jul 2005","","","IEEE","IEEE Conferences"
"Search-Based Web Service Antipatterns Detection","A. Ouni; M. Kessentini; K. Inoue; M. Ó. Cinnéide","Department of Computer Science, Osaka University, Japan; University of Michigan, Ann Arbor, MI; Department of Computer Science, Osaka University, Japan; School of Computer Science and Informatics, University College Dublin, Dublin, Ireland","IEEE Transactions on Services Computing","4 Aug 2017","2017","10","4","603","617","Service Oriented Architecture (SOA) is widely used in industry and is regarded as one of the preferred architectural design technologies. As with any other software system, service-based systems (SBSs) may suffer from poor design, i.e., antipatterns, for many reasons such as poorly planned changes, time pressure or bad design choices. Consequently, this may lead to an SBS product that is difficult to evolve and that exhibits poor quality of service (QoS). Detecting web service antipatterns is a manual, time-consuming and error-prone process for software developers. In this paper, we propose an automated approach for detection of web service antipatterns using a cooperative parallel evolutionary algorithm (P-EA). The idea is that several detection methods are combined and executed in parallel during an optimization process to find a consensus regarding the identification of web service antipatterns. We report the results of an empirical study using eight types of common web service antipatterns. We compare the implementation of our cooperative P-EA approach with random search, two single population-based approaches and one state-of-the-art detection technique not based on heuristic search. Statistical analysis of the obtained results demonstrates that our approach is efficient in antipattern detection, with a precision score of 89 percent and a recall score of 93 percent.","1939-1374","","10.1109/TSC.2015.2502595","Japan Society for the Promotion of Science; Grant-in-Aid for Scientific Research(grant numbers:25220003); Osaka University; Ford-University of Michigan alliance; Science Foundation Ireland(grant numbers:10/CE/I1855); Irish Software Research Centre; ","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332971","Web Services;web service design;antipattern;service-oriented computing;search-based software engineering","Web services;Measurement;Sociology;Statistics;Optimization;Business","cooperative systems;evolutionary computation;optimisation;parallel algorithms;quality of service;search problems;service-oriented architecture;statistical analysis;Web services","Web service antipatterns detection;service oriented architecture;SOA;service-based systems;SBSs;quality of service;QoS;cooperative parallel evolutionary algorithm;P-EA;optimization process;random search;statistical analysis","","48","","46","IEEE","20 Nov 2015","","","IEEE","IEEE Journals"
"Code smells in spreadsheet formulas revisited on an industrial dataset","B. Jansen; F. Hermans","Delft University of Technology, The Netherlands; Delft University of Technology, The Netherlands","2015 IEEE International Conference on Software Maintenance and Evolution (ICSME)","23 Nov 2015","2015","","","372","380","In previous work, code smells have been adapted to be applicable on spreadsheet formulas. The smell detection algorithm used in this earlier study was validated on a small dataset of industrial spreadsheets by interviewing the users of these spreadsheets and asking them about their opinion about the found smells. In this paper a more in depth validation of the algorithm is done by analyzing a set of spreadsheets of which users indicated whether or not they are smelly. This new dataset gives us the unique possibility to get more insight in how we can distinguish `bad' spreadsheets from `good' spreadsheets. We do that in two ways: For both the smelly and non smelly spreadsheets we 1) have calculated the metrics that detect the smells and 2) have calculated metrics with respect to size, level of coupling, and the use of functions. The results show that indeed the metrics for the smells decrease in spreadsheets that are not smelly. With respect to size we found to our surprise that the improved spreadsheets were not smaller, but bigger. With regard to coupling and the use of functions both datasets are similar. It indicates that it is difficult to use metrics with respect to size, degree of coupling or use of functions to draw conclusions on the complexity of a spreadsheet.","","978-1-4673-7532-0","10.1109/ICSM.2015.7332488","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7332488","","Couplings;Complexity theory;Standards;Programming;Companies;Length measurement","software engineering;spreadsheet programs","spreadsheet formula;code smell detection algorithm;industrial spreadsheet","","13","","13","IEEE","23 Nov 2015","","","IEEE","IEEE Conferences"
"Combining satellite-derived chlorophyll-a data and high-resolution dubaisat-1 data to detect and monitor red tide outbreaks in the Arabian Gulf","A. A. Muhairi; H. Ghedira; A. Shaheen","Assisstant Researcher, Space Program; Associate Professor of Water and Environmental Engineering, MASDAR Institute/MIT; Executive Director, Emirates Scientific Research Center, Dubai, UAE","2010 IEEE International Geoscience and Remote Sensing Symposium","3 Dec 2010","2010","","","3692","3695","Red tide is a common name for a phenomenon known as an algal bloom, an event in which estuarine, marine, or fresh water algae accumulate rapidly in the water column, or “bloom”. Red tide outbreaks are the result of an influx of a type of toxic algal bloom turning the water to a reddish color which can devastate marine plant and animal life. Red tide may cause a number of negative effects including the spread of bad smell in the air resulting from the organic decomposition of dead plant algae, death of large quantities of fishes and crustaceans, disturbance of fishing operations and suspending desalination plants operations. Recent red tide outbreaks have caused the closure of a number of beaches and have severely affected the fishery industry in the UAE (figure 1).","2153-7003","978-1-4244-9566-5","10.1109/IGARSS.2010.5651944","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=5651944","Red tide;MODIS FLH;DubaiSat;Arabian Gulf","Tides;MODIS;Sea measurements;Satellites;Monitoring;Image color analysis;Classification algorithms","oceanographic regions;tides","fresh water algae;water column;toxic algal bloom;marine plant;animal life;organic decomposition;dead plant algae;crustaceans;fishing operations;desalination plants operations;fishery industry;UAE;MODIS FLH;Arabian Gulf;chlorophyll-a data;high-resolution DubaiSat-1 data;red tide outbreaks","","","","8","IEEE","3 Dec 2010","","","IEEE","IEEE Conferences"
"Empirical Analysis of Fault-Proneness in Methods by Focusing on their Comment Lines","H. Aman; S. Amasaki; T. Sasaki; M. Kawahara","Center for Information Technology, Ehime University, Matsuyama, Japan; Faculty of Computer Science and Systems Engineering, Okayama Prefectural University, Soja, Japan; Center for Information Technology, Ehime University, Matsuyama, Japan; Center for Information Technology, Ehime University, Matsuyama, Japan","2014 21st Asia-Pacific Software Engineering Conference","23 Apr 2015","2014","2","","51","56","This paper focuses on comments described in Java programs, and conducts an empirical analysis about relationships between comments and fault-proneness in the programs. The types of comments analyzed in this paper are comments described inside a method body (inner comments), and comments followed by a method declaration (documentation comments). Although both of them play important roles in the program comprehension, they seem to be described in different purposes, The inner comments are often added to present tips about code fragments, while the documentation comments usually work as a programmer's manual. In the field of code refactoring, well-written inner comments are said to be related to ""code smell"" since they may cover a lack of readability in a complicated code fragment. This paper analyzes the associations of comments with the code quality from the aspect of fault-proneness, with using four popular open source products. The empirical results show that a method having inner comments tends to be 1.8 - 3.0 times likely to be faulty. The key contribution of this work is to reveal the usefulness of inner comments to point at faulty methods.","1530-1362","978-1-4799-7426-9","10.1109/APSEC.2014.93","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7091216","metrics;comments;fault-proneness","Documentation;Java;Measurement;Logistics;Electronic mail;History;Regression analysis","Java;software engineering","fault-proneness;comment lines;Java programs;empirical analysis;program comprehension;popular open source products;inner comments;documentation comments;software development","","5","","8","IEEE","23 Apr 2015","","","IEEE","IEEE Conferences"
"[Front cover]","",,"2017 IEEE Workshop on Machine Learning Techniques for Software Quality Evaluation (MaLTeSQuE)","23 Mar 2017","2017","","","c1","c1","The following topics are dealt with: software quality evaluation; machine learning; source code metrics; code smell co-occurrences; association rule learning; and bug detection.","","978-1-5090-6597-4","10.1109/MALTESQUE.2017.7882005","","https://ieeexplore.ieee.org/stamp/stamp.jsp?arnumber=7882005","","","learning (artificial intelligence);program debugging;software engineering","software quality evaluation;machine learning;source code metrics;code smell co-occurrences;association rule learning;bug detection","","","","","IEEE","23 Mar 2017","","","IEEE","IEEE Conferences"
